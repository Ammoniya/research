"""Main signature generation orchestrator."""

import json
from typing import List, Optional
from datetime import datetime
from collections import defaultdict

from .models import VulnerabilityInfo, CodeSignature, ProcessingStats
from .svn_extractor import SVNDiffExtractor
from .pattern_detector import PatternDetector
from .validators import SignatureValidator
from .progress_manager import ProgressManager, SignatureStorage
from .config import Config


class SignatureGenerator:
    """Orchestrates signature generation from vulnerabilities."""

    def __init__(self, config: Config):
        """
        Initialize signature generator.

        Args:
            config: Configuration object
        """
        self.config = config
        self.svn_extractor = SVNDiffExtractor(
            config.svn_repos_dir,
            config.diff_timeout
        )
        self.pattern_detector = PatternDetector(
            config.min_confidence_score
        )
        self.validator = SignatureValidator()
        self.progress_manager = ProgressManager(config.progress_file)
        self.signature_storage = SignatureStorage(config.signatures_output_dir)

    def generate_signature(
        self,
        vuln_info: VulnerabilityInfo,
        diff_content: str
    ) -> Optional[CodeSignature]:
        """
        Generate signature from vulnerability and diff.

        Args:
            vuln_info: Vulnerability information
            diff_content: Diff content string

        Returns:
            Optional[CodeSignature]: Generated signature or None
        """
        # Parse diff into blocks
        diff_blocks = self.svn_extractor.parse_diff_to_blocks(diff_content)

        if not diff_blocks:
            return None

        # Get diff statistics
        diff_stats = self.svn_extractor.get_diff_stats(diff_blocks)

        # Detect patterns
        detected_patterns = self.pattern_detector.detect_patterns_in_blocks(diff_blocks)

        if not detected_patterns:
            return None

        # Categorize as primary vs incidental
        categorized = self.pattern_detector.categorize_patterns(
            detected_patterns,
            vuln_info.vuln_type
        )

        primary_patterns = [p.to_string() for p in categorized['primary']]
        incidental_patterns = [p.to_string() for p in categorized['incidental']]

        # Generate abstract pattern
        pattern = self._generate_pattern_string(
            primary_patterns + incidental_patterns,
            vuln_info.vuln_type
        )

        # Assess severity
        severity_indicators = self._assess_severity(
            primary_patterns,
            vuln_info.vuln_type
        )

        # Calculate exploitability score
        exploitability_score = self._calculate_exploitability_score(
            severity_indicators,
            vuln_info.vuln_type
        )

        # Create signature
        signature = CodeSignature(
            cve=vuln_info.cve,
            plugin_slug=vuln_info.plugin_slug,
            vuln_type=vuln_info.vuln_type,
            signature_type='security_function_pattern',
            pattern=pattern,
            context={
                'title': vuln_info.title,
                'affected_versions': vuln_info.affected_versions,
                'patched_version': vuln_info.patched_version,
                'wordfence_uuid': vuln_info.wordfence_uuid,
                'detected_patterns': primary_patterns + incidental_patterns,
                'file_changes': diff_stats['file_changes'],
            },
            primary_patterns=primary_patterns,
            incidental_patterns=incidental_patterns,
            severity_indicators=severity_indicators,
            exploitability_score=exploitability_score,
            diff_before=self._extract_sample_code(diff_blocks, 'before'),
            diff_after=self._extract_sample_code(diff_blocks, 'after'),
            unified_diff=diff_content,
            diff_stats=diff_stats,
        )

        # Validate signature
        is_valid, notes = self.validator.validate(signature, diff_blocks)

        # Calculate quality score
        quality_score = self.validator.calculate_quality_score(signature)
        signature.context['quality_score'] = quality_score

        return signature

    def _generate_pattern_string(self, patterns: List[str], vuln_type: str) -> str:
        """Generate abstract pattern string."""
        if not patterns:
            return f"{vuln_type}::NO_PATTERN"

        # Group by category
        categories = defaultdict(list)
        for pattern in patterns:
            if ':' in pattern:
                category, func = pattern.split(':', 1)
                categories[category].append(func)

        # Build pattern string
        parts = []
        for category, funcs in sorted(categories.items()):
            parts.append(f"{category}[{','.join(sorted(set(funcs)))}]")

        return f"{vuln_type}::{'|'.join(parts)}"

    def _assess_severity(self, patterns: List[str], vuln_type: str) -> List[str]:
        """Assess severity indicators."""
        indicators = []

        # Critical: Missing authentication
        if any('AUTH:' in p for p in patterns):
            if 'CSRF' in vuln_type or 'Missing Authorization' in vuln_type:
                indicators.append('CRITICAL:MISSING_AUTH')

        # High: Missing input sanitization
        if any('SANITIZE:' in p for p in patterns):
            if 'XSS' in vuln_type or 'Injection' in vuln_type:
                indicators.append('HIGH:MISSING_SANITIZATION')

        # High: SQL injection
        if any('SQL_SECURITY:' in p for p in patterns):
            indicators.append('HIGH:SQL_INJECTION_RISK')

        # Critical: Unsafe file operations
        if any('FILE_SECURITY:' in p for p in patterns):
            if 'Traversal' in vuln_type or 'File' in vuln_type:
                indicators.append('CRITICAL:UNSAFE_FILE_OPS')

        # High: Missing output escaping
        if any('OUTPUT_ESC:' in p for p in patterns):
            if 'XSS' in vuln_type or 'Cross-Site Scripting' in vuln_type:
                indicators.append('HIGH:MISSING_OUTPUT_ESCAPING')

        # Critical: Dangerous function removed
        if any('REMOVED_DANGEROUS:' in p for p in patterns):
            indicators.append('CRITICAL:DANGEROUS_FUNCTION_REMOVED')

        # Medium: Missing validation
        if any('VALIDATION:' in p for p in patterns):
            indicators.append('MEDIUM:MISSING_VALIDATION')

        # Medium: Missing capability check
        if any('CAPABILITY:' in p for p in patterns):
            indicators.append('MEDIUM:MISSING_CAPABILITY_CHECK')

        return indicators

    def _calculate_exploitability_score(
        self,
        severity_indicators: List[str],
        vuln_type: str
    ) -> float:
        """Calculate exploitability score (0-10)."""
        score = 5.0  # Base score

        # Add based on severity
        critical_count = sum(1 for i in severity_indicators if 'CRITICAL:' in i)
        high_count = sum(1 for i in severity_indicators if 'HIGH:' in i)
        medium_count = sum(1 for i in severity_indicators if 'MEDIUM:' in i)

        score += critical_count * 2.0
        score += high_count * 1.0
        score += medium_count * 0.5

        # Add based on vulnerability type
        high_impact_types = [
            'SQL Injection',
            'Remote Code Execution',
            'Authentication Bypass',
            'Privilege Escalation',
            'Arbitrary File',
        ]

        if any(vuln in vuln_type for vuln in high_impact_types):
            score += 1.5

        return min(10.0, max(0.0, score))

    def _extract_sample_code(self, diff_blocks: List, code_type: str) -> str:
        """Extract sample code from diff blocks."""
        snippets = []
        for block in diff_blocks[:3]:  # First 3 files only
            if code_type == 'before' and block.before_code:
                snippets.append(f"File: {block.file_path}\n{block.before_code[:500]}")
            elif code_type == 'after' and block.after_code:
                snippets.append(f"File: {block.file_path}\n{block.after_code[:500]}")

        return '\n\n'.join(snippets)

    def save_consolidated_signatures(self, output_file: str):
        """
        Save all signatures to consolidated JSON file.

        Args:
            output_file: Path to output file
        """
        signatures = self.signature_storage.load_all_signatures()

        with open(output_file, 'w') as f:
            json.dump({
                'metadata': {
                    'generated_at': datetime.now().isoformat(),
                    'total_signatures': len(signatures),
                    'version': '2.0.0'
                },
                'signatures': signatures
            }, f, indent=2)

    def generate_statistics(self) -> dict:
        """
        Generate statistics from all signatures.

        Returns:
            dict: Statistics dictionary
        """
        signatures = self.signature_storage.load_all_signatures()

        vuln_type_counts = defaultdict(int)
        exploitability_scores = []
        quality_scores = []

        for sig in signatures:
            vuln_type_counts[sig['vuln_type']] += 1
            exploitability_scores.append(sig.get('exploitability_score', 0))

            quality = sig.get('context', {}).get('quality_score', 0)
            if quality > 0:
                quality_scores.append(quality)

        avg_exploitability = (
            sum(exploitability_scores) / len(exploitability_scores)
            if exploitability_scores else 0
        )

        avg_quality = (
            sum(quality_scores) / len(quality_scores)
            if quality_scores else 0
        )

        critical_count = sum(
            1 for sig in signatures
            if sig.get('exploitability_score', 0) >= 8.0
        )

        high_confidence_count = sum(
            1 for sig in signatures
            if sig.get('context', {}).get('quality_score', 0) >= 0.8
        )

        return {
            'total_signatures': len(signatures),
            'vuln_type_distribution': dict(vuln_type_counts),
            'avg_exploitability_score': round(avg_exploitability, 2),
            'avg_quality_score': round(avg_quality, 2),
            'critical_signatures': critical_count,
            'high_confidence_signatures': high_confidence_count,
        }
