"""Data models for vulnerability analysis."""

from dataclasses import dataclass, field, asdict
from typing import Dict, List, Optional, Any
from datetime import datetime
from enum import Enum


class PatternCategory(Enum):
    """Categories of security patterns."""
    AUTH = "AUTH"
    SANITIZE = "SANITIZE"
    SQL_SECURITY = "SQL_SECURITY"
    FILE_SECURITY = "FILE_SECURITY"
    OUTPUT_ESC = "OUTPUT_ESC"
    CAPABILITY = "CAPABILITY"
    VALIDATION = "VALIDATION"
    TYPE_CAST = "TYPE_CAST"
    REMOVED_DANGEROUS = "REMOVED_DANGEROUS"
    HTTP_REQUEST = "HTTP_REQUEST"
    CRYPTOGRAPHY = "CRYPTOGRAPHY"
    SERIALIZATION = "SERIALIZATION"
    REST_API = "REST_API"


class SeverityLevel(Enum):
    """Severity levels for vulnerabilities."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


@dataclass
class VulnerabilityInfo:
    """Structured vulnerability information."""
    cve: Optional[str]
    plugin_slug: str
    vuln_type: str
    title: str
    affected_versions: str
    patched_version: Optional[str]
    wordfence_uuid: Optional[str]
    references: List[str] = field(default_factory=list)

    def get_unique_id(self) -> str:
        """
        Generate unique identifier for this vulnerability.

        Returns:
            str: Unique ID (wordfence UUID or hash)
        """
        if self.wordfence_uuid:
            return self.wordfence_uuid

        import hashlib
        return hashlib.md5(
            f"{self.plugin_slug}:{self.cve}".encode()
        ).hexdigest()


@dataclass
class DiffBlock:
    """
    Represents a single block of diff output.

    Attributes:
        file_path: Path to the file being diffed
        before_code: Code from vulnerable version
        after_code: Code from patched version
        before_lines: Individual lines from before
        after_lines: Individual lines from after
        hunks: List of diff hunks
    """
    file_path: str
    before_code: str
    after_code: str
    before_lines: List[str] = field(default_factory=list)
    after_lines: List[str] = field(default_factory=list)
    hunks: List[Dict[str, Any]] = field(default_factory=list)

    def __post_init__(self):
        """Initialize line lists from code strings."""
        if not self.before_lines:
            self.before_lines = self.before_code.split('\n') if self.before_code else []
        if not self.after_lines:
            self.after_lines = self.after_code.split('\n') if self.after_code else []

    def get_added_lines(self) -> List[str]:
        """
        Get lines that were added in the patch.

        Returns:
            List[str]: Lines present in after but not in before
        """
        before_set = set(line.strip() for line in self.before_lines if line.strip())
        added = []
        for line in self.after_lines:
            if line.strip() and line.strip() not in before_set:
                added.append(line)
        return added

    def get_removed_lines(self) -> List[str]:
        """
        Get lines that were removed in the patch.

        Returns:
            List[str]: Lines present in before but not in after
        """
        after_set = set(line.strip() for line in self.after_lines if line.strip())
        removed = []
        for line in self.before_lines:
            if line.strip() and line.strip() not in after_set:
                removed.append(line)
        return removed

    def is_php_file(self) -> bool:
        """Check if this is a PHP file."""
        return self.file_path.endswith('.php')

    def get_file_name(self) -> str:
        """Get just the filename without path."""
        return self.file_path.split('/')[-1]


@dataclass
class DetectedPattern:
    """
    Represents a detected security pattern with context.

    Attributes:
        category: Pattern category (AUTH, SANITIZE, etc.)
        function_name: Name of the security function
        confidence: Confidence score (0.0 to 1.0)
        line_number: Line number where pattern was found
        context_lines: Surrounding code lines
        in_actual_code: Whether pattern is in actual code (not comment)
    """
    category: str
    function_name: str
    confidence: float
    line_number: int = 0
    context_lines: List[str] = field(default_factory=list)
    in_actual_code: bool = True

    def to_string(self) -> str:
        """Convert to category:function format."""
        return f"{self.category}:{self.function_name}"

    def is_high_confidence(self, threshold: float = 0.7) -> bool:
        """Check if confidence meets threshold."""
        return self.confidence >= threshold


@dataclass
class CodeSignature:
    """
    Simplified vulnerability patch data.

    Stores only the essential information:
    - Vulnerability metadata (CVE, plugin, type, versions)
    - Patch location (which versions were compared)
    - Pre-patch code (vulnerable version)
    - Post-patch code (fixed version)
    - Full unified diff
    """
    # Vulnerability metadata
    cve: Optional[str]
    plugin_slug: str
    vuln_type: str
    title: str
    wordfence_uuid: Optional[str] = None

    # Version information
    vulnerable_version: str = ""
    patched_version: str = ""
    affected_versions: str = ""

    # Patch location and diff data
    patch_location: str = ""  # e.g., "1.2.3 -> 1.2.4"
    pre_patch_code: str = ""  # Code from vulnerable version
    post_patch_code: str = ""  # Code from patched version
    unified_diff: str = ""  # Full unified diff

    # Basic diff statistics
    files_changed: int = 0
    lines_added: int = 0
    lines_removed: int = 0

    # AST signatures (generated from actual files)
    ast_signatures: List[Dict[str, Any]] = field(default_factory=list)

    # Metadata
    extracted_at: str = field(default_factory=lambda: datetime.now().isoformat())
    references: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return asdict(self)

    def to_markdown(self) -> str:
        """
        Convert signature to readable Markdown format.

        Returns:
            str: Formatted markdown document
        """
        # Header
        title = self.cve if self.cve and self.cve != 'N/A' else f"{self.vuln_type} Vulnerability"
        md = f"# {title}\n\n"

        # Basic info
        md += f"**Plugin**: {self.plugin_slug}\n"
        md += f"**Type**: {self.vuln_type}\n"
        md += f"**Title**: {self.title}\n"
        md += f"**Patch**: {self.patch_location}\n\n"

        # Details section
        md += "## Vulnerability Details\n\n"
        md += f"- **Affected Versions**: {self.affected_versions}\n"
        md += f"- **Vulnerable Version**: {self.vulnerable_version}\n"
        md += f"- **Patched Version**: {self.patched_version}\n"
        if self.cve and self.cve != 'N/A':
            md += f"- **CVE**: {self.cve}\n"
        if self.wordfence_uuid:
            md += f"- **Wordfence UUID**: {self.wordfence_uuid}\n"
        md += f"- **Extracted**: {self.extracted_at}\n\n"

        # Patch statistics
        md += "## Patch Statistics\n\n"
        md += f"- **Files Changed**: {self.files_changed}\n"
        md += f"- **Lines Added**: +{self.lines_added}\n"
        md += f"- **Lines Removed**: -{self.lines_removed}\n\n"

        # Pre-patch code
        if self.pre_patch_code:
            md += "## Pre-Patch Code (Vulnerable Version)\n\n"
            md += "```php\n"
            md += self.pre_patch_code
            md += "\n```\n\n"

        # Post-patch code
        if self.post_patch_code:
            md += "## Post-Patch Code (Fixed Version)\n\n"
            md += "```php\n"
            md += self.post_patch_code
            md += "\n```\n\n"

        # Unified diff
        if self.unified_diff:
            md += "## Unified Diff\n\n"
            md += "```diff\n"
            md += self.unified_diff
            md += "\n```\n\n"

        # References
        if self.references:
            md += "## References\n\n"
            for ref in self.references:
                md += f"- {ref}\n"
            md += "\n"

        return md


@dataclass
class ProcessingStats:
    """Statistics for signature generation process."""
    total_vulnerabilities: int = 0
    processed: int = 0
    success: int = 0
    failed: int = 0
    skipped: int = 0
    high_confidence: int = 0
    medium_confidence: int = 0
    low_confidence: int = 0

    def success_rate(self) -> float:
        """Calculate success rate percentage."""
        if self.processed == 0:
            return 0.0
        return (self.success / self.processed) * 100

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return asdict(self)


@dataclass
class ASTNode:
    """
    Represents a node in the Abstract Syntax Tree.

    Attributes:
        node_type: Type of the AST node (e.g., 'function_definition', 'if_statement')
        text: Source code text of this node
        start_byte: Starting byte position in source
        end_byte: Ending byte position in source
        start_point: Starting (row, col) position
        end_point: Ending (row, col) position
        children: Child nodes
        field_name: Field name if this node is a named field
    """
    node_type: str
    text: str = ""
    start_byte: int = 0
    end_byte: int = 0
    start_point: tuple = field(default_factory=lambda: (0, 0))
    end_point: tuple = field(default_factory=lambda: (0, 0))
    children: List['ASTNode'] = field(default_factory=list)
    field_name: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            'node_type': self.node_type,
            'text': self.text,
            'start_byte': self.start_byte,
            'end_byte': self.end_byte,
            'start_point': self.start_point,
            'end_point': self.end_point,
            'field_name': self.field_name,
            'children': [child.to_dict() for child in self.children]
        }

    def get_node_signature(self) -> str:
        """
        Get a simplified signature of this node for comparison.
        Returns type and structure without specific values.
        """
        if not self.children:
            return self.node_type

        child_sigs = [child.get_node_signature() for child in self.children]
        return f"{self.node_type}({','.join(child_sigs)})"


@dataclass
class ASTDiff:
    """
    Represents a difference between two AST nodes.

    Attributes:
        diff_type: Type of difference ('added', 'removed', 'modified')
        vulnerable_node: Node from vulnerable version (None if added)
        patched_node: Node from patched version (None if removed)
        path: Path to this diff in the tree (list of node types)
        description: Human-readable description of the change
    """
    diff_type: str  # 'added', 'removed', 'modified'
    vulnerable_node: Optional[ASTNode] = None
    patched_node: Optional[ASTNode] = None
    path: List[str] = field(default_factory=list)
    description: str = ""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            'diff_type': self.diff_type,
            'vulnerable_node': self.vulnerable_node.to_dict() if self.vulnerable_node else None,
            'patched_node': self.patched_node.to_dict() if self.patched_node else None,
            'path': self.path,
            'description': self.description
        }


@dataclass
class ASTSignature:
    """
    Complete AST-based signature for a vulnerability.

    Stores the AST representation of vulnerable and patched code,
    along with the minimal differing subtrees that represent the
    vulnerability pattern and its fix.

    Attributes:
        cve: CVE identifier
        plugin_slug: WordPress plugin slug
        vuln_type: Vulnerability type
        vulnerable_ast: AST of vulnerable code
        patched_ast: AST of patched code
        minimal_diffs: List of minimal differing subtrees
        file_path: Path to the file that was changed
        vulnerable_version: Version with vulnerability
        patched_version: Version with patch
        extracted_at: Timestamp of extraction
    """
    # Metadata
    cve: Optional[str]
    plugin_slug: str
    vuln_type: str
    title: str
    wordfence_uuid: Optional[str] = None

    # Version information
    vulnerable_version: str = ""
    patched_version: str = ""
    file_path: str = ""

    # AST data
    vulnerable_ast: Optional[ASTNode] = None
    patched_ast: Optional[ASTNode] = None
    minimal_diffs: List[ASTDiff] = field(default_factory=list)

    # Original code for reference
    vulnerable_code: str = ""
    patched_code: str = ""

    # Metadata
    extracted_at: str = field(default_factory=lambda: datetime.now().isoformat())
    references: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            'cve': self.cve,
            'plugin_slug': self.plugin_slug,
            'vuln_type': self.vuln_type,
            'title': self.title,
            'wordfence_uuid': self.wordfence_uuid,
            'vulnerable_version': self.vulnerable_version,
            'patched_version': self.patched_version,
            'file_path': self.file_path,
            'vulnerable_ast': self.vulnerable_ast.to_dict() if self.vulnerable_ast else None,
            'patched_ast': self.patched_ast.to_dict() if self.patched_ast else None,
            'minimal_diffs': [diff.to_dict() for diff in self.minimal_diffs],
            'vulnerable_code': self.vulnerable_code,
            'patched_code': self.patched_code,
            'extracted_at': self.extracted_at,
            'references': self.references
        }

    def get_vulnerable_pattern(self) -> List[ASTNode]:
        """
        Extract the vulnerable pattern nodes from minimal diffs.

        Returns:
            List of AST nodes representing the vulnerable pattern
        """
        patterns = []
        for diff in self.minimal_diffs:
            if diff.vulnerable_node:
                patterns.append(diff.vulnerable_node)
        return patterns

    def get_patched_pattern(self) -> List[ASTNode]:
        """
        Extract the patched pattern nodes from minimal diffs.

        Returns:
            List of AST nodes representing the patched pattern
        """
        patterns = []
        for diff in self.minimal_diffs:
            if diff.patched_node:
                patterns.append(diff.patched_node)
        return patterns
