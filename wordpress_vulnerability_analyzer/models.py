"""Data models for vulnerability analysis."""

from dataclasses import dataclass, field, asdict
from typing import Dict, List, Optional, Any
from datetime import datetime
from enum import Enum


class PatternCategory(Enum):
    """Categories of security patterns."""
    AUTH = "AUTH"
    SANITIZE = "SANITIZE"
    SQL_SECURITY = "SQL_SECURITY"
    FILE_SECURITY = "FILE_SECURITY"
    OUTPUT_ESC = "OUTPUT_ESC"
    CAPABILITY = "CAPABILITY"
    VALIDATION = "VALIDATION"
    TYPE_CAST = "TYPE_CAST"
    REMOVED_DANGEROUS = "REMOVED_DANGEROUS"
    HTTP_REQUEST = "HTTP_REQUEST"
    CRYPTOGRAPHY = "CRYPTOGRAPHY"
    SERIALIZATION = "SERIALIZATION"
    REST_API = "REST_API"


class SeverityLevel(Enum):
    """Severity levels for vulnerabilities."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


@dataclass
class VulnerabilityInfo:
    """Structured vulnerability information."""
    cve: Optional[str]
    plugin_slug: str
    vuln_type: str
    title: str
    affected_versions: str
    patched_version: Optional[str]
    wordfence_uuid: Optional[str]
    references: List[str] = field(default_factory=list)

    def get_unique_id(self) -> str:
        """
        Generate unique identifier for this vulnerability.

        Returns:
            str: Unique ID (wordfence UUID or hash)
        """
        if self.wordfence_uuid:
            return self.wordfence_uuid

        import hashlib
        return hashlib.md5(
            f"{self.plugin_slug}:{self.cve}".encode()
        ).hexdigest()


@dataclass
class DiffBlock:
    """
    Represents a single block of diff output.

    Attributes:
        file_path: Path to the file being diffed
        before_code: Code from vulnerable version
        after_code: Code from patched version
        before_lines: Individual lines from before
        after_lines: Individual lines from after
        hunks: List of diff hunks
    """
    file_path: str
    before_code: str
    after_code: str
    before_lines: List[str] = field(default_factory=list)
    after_lines: List[str] = field(default_factory=list)
    hunks: List[Dict[str, Any]] = field(default_factory=list)

    def __post_init__(self):
        """Initialize line lists from code strings."""
        if not self.before_lines:
            self.before_lines = self.before_code.split('\n') if self.before_code else []
        if not self.after_lines:
            self.after_lines = self.after_code.split('\n') if self.after_code else []

    def get_added_lines(self) -> List[str]:
        """
        Get lines that were added in the patch.

        Returns:
            List[str]: Lines present in after but not in before
        """
        before_set = set(line.strip() for line in self.before_lines if line.strip())
        added = []
        for line in self.after_lines:
            if line.strip() and line.strip() not in before_set:
                added.append(line)
        return added

    def get_removed_lines(self) -> List[str]:
        """
        Get lines that were removed in the patch.

        Returns:
            List[str]: Lines present in before but not in after
        """
        after_set = set(line.strip() for line in self.after_lines if line.strip())
        removed = []
        for line in self.before_lines:
            if line.strip() and line.strip() not in after_set:
                removed.append(line)
        return removed

    def is_php_file(self) -> bool:
        """Check if this is a PHP file."""
        return self.file_path.endswith('.php')

    def get_file_name(self) -> str:
        """Get just the filename without path."""
        return self.file_path.split('/')[-1]


@dataclass
class DetectedPattern:
    """
    Represents a detected security pattern with context.

    Attributes:
        category: Pattern category (AUTH, SANITIZE, etc.)
        function_name: Name of the security function
        confidence: Confidence score (0.0 to 1.0)
        line_number: Line number where pattern was found
        context_lines: Surrounding code lines
        in_actual_code: Whether pattern is in actual code (not comment)
    """
    category: str
    function_name: str
    confidence: float
    line_number: int = 0
    context_lines: List[str] = field(default_factory=list)
    in_actual_code: bool = True

    def to_string(self) -> str:
        """Convert to category:function format."""
        return f"{self.category}:{self.function_name}"

    def is_high_confidence(self, threshold: float = 0.7) -> bool:
        """Check if confidence meets threshold."""
        return self.confidence >= threshold


@dataclass
class CodeSignature:
    """
    Simplified vulnerability patch data.

    Stores only the essential information:
    - Vulnerability metadata (CVE, plugin, type, versions)
    - Patch location (which versions were compared)
    - Pre-patch code (vulnerable version)
    - Post-patch code (fixed version)
    - Full unified diff
    """
    # Vulnerability metadata
    cve: Optional[str]
    plugin_slug: str
    vuln_type: str
    title: str
    wordfence_uuid: Optional[str] = None

    # Version information
    vulnerable_version: str = ""
    patched_version: str = ""
    affected_versions: str = ""

    # Patch location and diff data
    patch_location: str = ""  # e.g., "1.2.3 -> 1.2.4"
    pre_patch_code: str = ""  # Code from vulnerable version
    post_patch_code: str = ""  # Code from patched version
    unified_diff: str = ""  # Full unified diff

    # Basic diff statistics
    files_changed: int = 0
    lines_added: int = 0
    lines_removed: int = 0

    # Metadata
    extracted_at: str = field(default_factory=lambda: datetime.now().isoformat())
    references: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return asdict(self)

    def to_markdown(self) -> str:
        """
        Convert signature to readable Markdown format.

        Returns:
            str: Formatted markdown document
        """
        # Header
        title = self.cve if self.cve and self.cve != 'N/A' else f"{self.vuln_type} Vulnerability"
        md = f"# {title}\n\n"

        # Basic info
        md += f"**Plugin**: {self.plugin_slug}\n"
        md += f"**Type**: {self.vuln_type}\n"
        md += f"**Title**: {self.title}\n"
        md += f"**Patch**: {self.patch_location}\n\n"

        # Details section
        md += "## Vulnerability Details\n\n"
        md += f"- **Affected Versions**: {self.affected_versions}\n"
        md += f"- **Vulnerable Version**: {self.vulnerable_version}\n"
        md += f"- **Patched Version**: {self.patched_version}\n"
        if self.cve and self.cve != 'N/A':
            md += f"- **CVE**: {self.cve}\n"
        if self.wordfence_uuid:
            md += f"- **Wordfence UUID**: {self.wordfence_uuid}\n"
        md += f"- **Extracted**: {self.extracted_at}\n\n"

        # Patch statistics
        md += "## Patch Statistics\n\n"
        md += f"- **Files Changed**: {self.files_changed}\n"
        md += f"- **Lines Added**: +{self.lines_added}\n"
        md += f"- **Lines Removed**: -{self.lines_removed}\n\n"

        # Pre-patch code
        if self.pre_patch_code:
            md += "## Pre-Patch Code (Vulnerable Version)\n\n"
            md += "```php\n"
            md += self.pre_patch_code
            md += "\n```\n\n"

        # Post-patch code
        if self.post_patch_code:
            md += "## Post-Patch Code (Fixed Version)\n\n"
            md += "```php\n"
            md += self.post_patch_code
            md += "\n```\n\n"

        # Unified diff
        if self.unified_diff:
            md += "## Unified Diff\n\n"
            md += "```diff\n"
            md += self.unified_diff
            md += "\n```\n\n"

        # References
        if self.references:
            md += "## References\n\n"
            for ref in self.references:
                md += f"- {ref}\n"
            md += "\n"

        return md


@dataclass
class ProcessingStats:
    """Statistics for signature generation process."""
    total_vulnerabilities: int = 0
    processed: int = 0
    success: int = 0
    failed: int = 0
    skipped: int = 0
    high_confidence: int = 0
    medium_confidence: int = 0
    low_confidence: int = 0

    def success_rate(self) -> float:
        """Calculate success rate percentage."""
        if self.processed == 0:
            return 0.0
        return (self.success / self.processed) * 100

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return asdict(self)
