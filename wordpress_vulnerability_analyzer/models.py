"""Data models for vulnerability analysis."""

from dataclasses import dataclass, field, asdict
from typing import Dict, List, Optional, Any
from datetime import datetime
from enum import Enum


class PatternCategory(Enum):
    """Categories of security patterns."""
    AUTH = "AUTH"
    SANITIZE = "SANITIZE"
    SQL_SECURITY = "SQL_SECURITY"
    FILE_SECURITY = "FILE_SECURITY"
    OUTPUT_ESC = "OUTPUT_ESC"
    CAPABILITY = "CAPABILITY"
    VALIDATION = "VALIDATION"
    TYPE_CAST = "TYPE_CAST"
    REMOVED_DANGEROUS = "REMOVED_DANGEROUS"
    HTTP_REQUEST = "HTTP_REQUEST"
    CRYPTOGRAPHY = "CRYPTOGRAPHY"
    SERIALIZATION = "SERIALIZATION"
    REST_API = "REST_API"


class SeverityLevel(Enum):
    """Severity levels for vulnerabilities."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


@dataclass
class VulnerabilityInfo:
    """Structured vulnerability information."""
    cve: Optional[str]
    plugin_slug: str
    vuln_type: str
    title: str
    affected_versions: str
    patched_version: Optional[str]
    wordfence_uuid: Optional[str]
    references: List[str] = field(default_factory=list)

    def get_unique_id(self) -> str:
        """
        Generate unique identifier for this vulnerability.

        Returns:
            str: Unique ID (wordfence UUID or hash)
        """
        if self.wordfence_uuid:
            return self.wordfence_uuid

        import hashlib
        return hashlib.md5(
            f"{self.plugin_slug}:{self.cve}".encode()
        ).hexdigest()


@dataclass
class DiffBlock:
    """
    Represents a single block of diff output.

    Attributes:
        file_path: Path to the file being diffed
        before_code: Code from vulnerable version
        after_code: Code from patched version
        before_lines: Individual lines from before
        after_lines: Individual lines from after
        hunks: List of diff hunks
    """
    file_path: str
    before_code: str
    after_code: str
    before_lines: List[str] = field(default_factory=list)
    after_lines: List[str] = field(default_factory=list)
    hunks: List[Dict[str, Any]] = field(default_factory=list)

    def __post_init__(self):
        """Initialize line lists from code strings."""
        if not self.before_lines:
            self.before_lines = self.before_code.split('\n') if self.before_code else []
        if not self.after_lines:
            self.after_lines = self.after_code.split('\n') if self.after_code else []

    def get_added_lines(self) -> List[str]:
        """
        Get lines that were added in the patch.

        Returns:
            List[str]: Lines present in after but not in before
        """
        before_set = set(line.strip() for line in self.before_lines if line.strip())
        added = []
        for line in self.after_lines:
            if line.strip() and line.strip() not in before_set:
                added.append(line)
        return added

    def get_removed_lines(self) -> List[str]:
        """
        Get lines that were removed in the patch.

        Returns:
            List[str]: Lines present in before but not in after
        """
        after_set = set(line.strip() for line in self.after_lines if line.strip())
        removed = []
        for line in self.before_lines:
            if line.strip() and line.strip() not in after_set:
                removed.append(line)
        return removed

    def is_php_file(self) -> bool:
        """Check if this is a PHP file."""
        return self.file_path.endswith('.php')

    def get_file_name(self) -> str:
        """Get just the filename without path."""
        return self.file_path.split('/')[-1]


@dataclass
class DetectedPattern:
    """
    Represents a detected security pattern with context.

    Attributes:
        category: Pattern category (AUTH, SANITIZE, etc.)
        function_name: Name of the security function
        confidence: Confidence score (0.0 to 1.0)
        line_number: Line number where pattern was found
        context_lines: Surrounding code lines
        in_actual_code: Whether pattern is in actual code (not comment)
    """
    category: str
    function_name: str
    confidence: float
    line_number: int = 0
    context_lines: List[str] = field(default_factory=list)
    in_actual_code: bool = True

    def to_string(self) -> str:
        """Convert to category:function format."""
        return f"{self.category}:{self.function_name}"

    def is_high_confidence(self, threshold: float = 0.7) -> bool:
        """Check if confidence meets threshold."""
        return self.confidence >= threshold


@dataclass
class CodeSignature:
    """
    Abstract signature extracted from vulnerability diff.

    Attributes:
        cve: CVE identifier
        plugin_slug: Plugin identifier
        vuln_type: Vulnerability type
        signature_type: Type of signature
        pattern: Abstract pattern string
        context: Additional context
        primary_patterns: Patterns matching vulnerability type
        incidental_patterns: Other security improvements
        severity_indicators: Severity assessment
        exploitability_score: Calculated risk score
        diff_before: Sample vulnerable code
        diff_after: Sample patched code
        unified_diff: Full unified diff in git format
        diff_stats: Statistics about the diff
        extracted_at: Timestamp of extraction
        validated: Whether signature has been validated
        validation_notes: Notes from validation
    """
    cve: Optional[str]
    plugin_slug: str
    vuln_type: str
    signature_type: str
    pattern: str
    context: Dict[str, Any]
    primary_patterns: List[str] = field(default_factory=list)
    incidental_patterns: List[str] = field(default_factory=list)
    severity_indicators: List[str] = field(default_factory=list)
    exploitability_score: float = 5.0
    diff_before: str = ""
    diff_after: str = ""
    unified_diff: str = ""
    diff_stats: Dict[str, int] = field(default_factory=dict)
    extracted_at: str = field(default_factory=lambda: datetime.now().isoformat())
    validated: bool = False
    validation_notes: List[str] = field(default_factory=list)

    def get_all_patterns(self) -> List[str]:
        """Get all detected patterns (primary + incidental)."""
        return self.primary_patterns + self.incidental_patterns

    def is_critical(self) -> bool:
        """Check if this is a critical severity signature."""
        return any('CRITICAL:' in ind for ind in self.severity_indicators)

    def is_high_confidence(self) -> bool:
        """
        Check if this is a high-confidence signature.

        A signature is high-confidence if:
        - It has only one pattern (no ambiguity)
        - The pattern matches the vulnerability type
        - Diff involves few files (< 5)
        """
        return (
            len(self.get_all_patterns()) == 1 and
            len(self.primary_patterns) > 0 and
            self.diff_stats.get('file_changes', 999) < 5
        )

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return asdict(self)


@dataclass
class ProcessingStats:
    """Statistics for signature generation process."""
    total_vulnerabilities: int = 0
    processed: int = 0
    success: int = 0
    failed: int = 0
    skipped: int = 0
    high_confidence: int = 0
    medium_confidence: int = 0
    low_confidence: int = 0

    def success_rate(self) -> float:
        """Calculate success rate percentage."""
        if self.processed == 0:
            return 0.0
        return (self.success / self.processed) * 100

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return asdict(self)
