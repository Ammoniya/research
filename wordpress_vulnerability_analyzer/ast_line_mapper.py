"""
AST Line Mapper - maps AST nodes to source code line ranges.

This module provides functionality to map AST nodes to their corresponding
line numbers in the source code, which is essential for locating which nodes
changed based on diff line ranges.
"""

from typing import List, Tuple, Optional, Set
from wordpress_vulnerability_analyzer.models import ASTNode


class ASTLineMapper:
    """
    Maps AST nodes to source code line ranges and finds nodes in specific ranges.

    This class helps identify which AST nodes correspond to changed lines
    in a diff, enabling precise extraction of vulnerability patterns.
    """

    def __init__(self):
        """Initialize the line mapper."""
        pass

    def find_nodes_in_range(
        self,
        root: ASTNode,
        start_line: int,
        end_line: int
    ) -> List[ASTNode]:
        """
        Find all AST nodes that intersect with a line range.

        Args:
            root: Root AST node to search
            start_line: Start line (1-indexed)
            end_line: End line (1-indexed, inclusive)

        Returns:
            List of nodes that intersect the line range
        """
        nodes = []
        self._find_nodes_in_range_recursive(root, start_line, end_line, nodes)
        return nodes

    def _find_nodes_in_range_recursive(
        self,
        node: ASTNode,
        start_line: int,
        end_line: int,
        result: List[ASTNode]
    ):
        """
        Recursively find nodes in range.

        Args:
            node: Current node
            start_line: Start line (1-indexed)
            end_line: End line (1-indexed)
            result: List to append matching nodes to
        """
        # Convert tree-sitter 0-indexed lines to 1-indexed
        node_start_line = node.start_point[0] + 1
        node_end_line = node.end_point[0] + 1

        # Check if node intersects with range
        if node_end_line >= start_line and node_start_line <= end_line:
            result.append(node)

            # Check children too
            for child in node.children:
                self._find_nodes_in_range_recursive(child, start_line, end_line, result)

    def find_minimal_changed_nodes(
        self,
        root: ASTNode,
        changed_ranges: List[Tuple[int, int]]
    ) -> List[ASTNode]:
        """
        Find the minimal (most specific) nodes that cover all changed ranges.

        Args:
            root: Root AST node
            changed_ranges: List of (start_line, end_line) tuples

        Returns:
            List of minimal nodes covering all changes
        """
        all_nodes = []

        # Find all nodes for each range
        for start_line, end_line in changed_ranges:
            nodes = self.find_nodes_in_range(root, start_line, end_line)
            all_nodes.extend(nodes)

        # Find minimal nodes (deepest/most specific)
        minimal_nodes = self._filter_to_minimal(all_nodes)

        return minimal_nodes

    def _filter_to_minimal(self, nodes: List[ASTNode]) -> List[ASTNode]:
        """
        Filter nodes to only the most specific (deepest) ones.

        If a parent and child are both in the list, only keep the child.

        Args:
            nodes: List of AST nodes

        Returns:
            List of minimal (most specific) nodes
        """
        if not nodes:
            return []

        # Build a set of all ancestor nodes for quick lookup
        ancestor_set = set()

        for node in nodes:
            self._collect_ancestors(node, ancestor_set)

        # Keep only nodes that aren't ancestors of other nodes
        minimal = []
        for node in nodes:
            # Check if this node is an ancestor of any other node in the list
            is_ancestor = False
            for other in nodes:
                if other != node and self._is_ancestor(node, other):
                    is_ancestor = True
                    break

            if not is_ancestor:
                minimal.append(node)

        return minimal

    def _collect_ancestors(self, node: ASTNode, ancestors: Set[ASTNode]):
        """
        Collect all ancestor nodes (parent, grandparent, etc.).

        Args:
            node: Node to get ancestors for
            ancestors: Set to add ancestors to
        """
        # Note: Our ASTNode doesn't have parent pointers, so we can't
        # easily traverse up. Instead, we'll use a different approach
        # based on containment (byte ranges).
        pass

    def _is_ancestor(self, potential_ancestor: ASTNode, node: ASTNode) -> bool:
        """
        Check if potential_ancestor is an ancestor of node.

        Uses byte ranges to determine containment.

        Args:
            potential_ancestor: Node that might be an ancestor
            node: Node to check

        Returns:
            True if potential_ancestor contains node
        """
        # An ancestor completely contains its descendants
        return (
            potential_ancestor.start_byte <= node.start_byte and
            potential_ancestor.end_byte >= node.end_byte and
            # Not the same node
            not (potential_ancestor.start_byte == node.start_byte and
                 potential_ancestor.end_byte == node.end_byte)
        )

    def find_smallest_differing_node(
        self,
        vuln_root: ASTNode,
        patch_root: ASTNode,
        changed_ranges: List[Tuple[int, int]]
    ) -> Optional[Tuple[ASTNode, ASTNode]]:
        """
        Find the smallest pair of nodes that differ between versions.

        Args:
            vuln_root: Root of vulnerable version AST
            patch_root: Root of patched version AST
            changed_ranges: List of changed line ranges

        Returns:
            Tuple of (vuln_node, patch_node) or None if not found
        """
        # Find minimal nodes in vulnerable version
        vuln_nodes = self.find_minimal_changed_nodes(vuln_root, changed_ranges)

        if not vuln_nodes:
            return None

        # For each vulnerable node, try to find corresponding node in patched version
        # We'll use position/line as a hint, but mainly look for structural similarity

        # For simplicity, return the first minimal node pair
        # In a more sophisticated version, we'd do structural matching
        if vuln_nodes:
            # Find corresponding node in patched version at same position
            vuln_node = vuln_nodes[0]
            vuln_line = vuln_node.start_point[0] + 1

            # Find node at approximately the same position in patched version
            patch_nodes = self.find_nodes_in_range(patch_root, vuln_line, vuln_line)

            if patch_nodes:
                # Find node with same type
                for patch_node in patch_nodes:
                    if patch_node.node_type == vuln_node.node_type:
                        return (vuln_node, patch_node)

                # If no exact type match, return first node
                return (vuln_node, patch_nodes[0])

        return None

    def get_node_context(
        self,
        node: ASTNode,
        context_lines: int = 3
    ) -> Tuple[int, int]:
        """
        Get line range including context around a node.

        Args:
            node: AST node
            context_lines: Number of context lines to include before/after

        Returns:
            Tuple of (start_line, end_line) with context
        """
        node_start = node.start_point[0] + 1
        node_end = node.end_point[0] + 1

        start_with_context = max(1, node_start - context_lines)
        end_with_context = node_end + context_lines

        return (start_with_context, end_with_context)

    def extract_node_text(self, node: ASTNode, source_code: str) -> str:
        """
        Extract the source code text for a node.

        Args:
            node: AST node
            source_code: Full source code

        Returns:
            Text for the node
        """
        # If node already has text, return it
        if node.text:
            return node.text

        # Otherwise extract from source code using byte ranges
        source_bytes = source_code.encode('utf-8')
        return source_bytes[node.start_byte:node.end_byte].decode('utf-8', errors='ignore')
