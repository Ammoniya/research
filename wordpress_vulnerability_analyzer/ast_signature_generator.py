"""
AST Signature Generator - orchestrates the generation of AST-based signatures.

This module coordinates the entire pipeline:
1. Load CVE data from JSON
2. Extract unified diffs
3. Parse pre/post patch code into ASTs
4. Diff the ASTs
5. Generate and store signatures
"""

import json
from pathlib import Path
from typing import Optional, Dict, List
from datetime import datetime

from wordpress_vulnerability_analyzer.models import (
    CodeSignature, ASTSignature, ASTNode, ASTDiff
)
from wordpress_vulnerability_analyzer.ast_parser import PHPASTParser
from wordpress_vulnerability_analyzer.ast_differ import ASTDiffer


class ASTSignatureGenerator:
    """
    Generates AST-based signatures from CVE data.

    This class orchestrates the entire pipeline of loading CVE data,
    parsing code into ASTs, comparing them, and generating signatures.
    """

    def __init__(self, verbose: bool = False):
        """
        Initialize the AST signature generator.

        Args:
            verbose: Whether to print detailed progress information
        """
        self.verbose = verbose
        self.parser = PHPASTParser()
        self.differ = ASTDiffer(ignore_whitespace=True, ignore_comments=True)

    def generate_from_code_signature(
        self,
        code_signature: CodeSignature
    ) -> Optional[ASTSignature]:
        """
        Generate an AST signature from an existing CodeSignature.

        Args:
            code_signature: Existing code signature with diff data

        Returns:
            ASTSignature object, or None if generation fails
        """
        if not code_signature.pre_patch_code or not code_signature.post_patch_code:
            if self.verbose:
                print(f"Skipping {code_signature.cve}: missing pre/post patch code")
            return None

        return self.generate_from_code(
            cve=code_signature.cve,
            plugin_slug=code_signature.plugin_slug,
            vuln_type=code_signature.vuln_type,
            title=code_signature.title,
            vulnerable_code=code_signature.pre_patch_code,
            patched_code=code_signature.post_patch_code,
            vulnerable_version=code_signature.vulnerable_version,
            patched_version=code_signature.patched_version,
            wordfence_uuid=code_signature.wordfence_uuid,
            references=code_signature.references
        )

    def generate_from_code(
        self,
        cve: Optional[str],
        plugin_slug: str,
        vuln_type: str,
        title: str,
        vulnerable_code: str,
        patched_code: str,
        vulnerable_version: str = "",
        patched_version: str = "",
        wordfence_uuid: Optional[str] = None,
        references: List[str] = None,
        file_path: str = ""
    ) -> Optional[ASTSignature]:
        """
        Generate an AST signature from code snippets.

        Args:
            cve: CVE identifier
            plugin_slug: Plugin slug
            vuln_type: Vulnerability type
            title: Vulnerability title
            vulnerable_code: Code from vulnerable version
            patched_code: Code from patched version
            vulnerable_version: Version number with vulnerability
            patched_version: Version number with patch
            wordfence_uuid: Wordfence UUID
            references: List of reference URLs
            file_path: Path to the file that was changed

        Returns:
            ASTSignature object, or None if generation fails
        """
        if references is None:
            references = []

        if self.verbose:
            print(f"\nGenerating AST signature for {cve or 'unknown CVE'}")
            print(f"  Plugin: {plugin_slug}")
            print(f"  Type: {vuln_type}")

        # Parse vulnerable code
        if self.verbose:
            print("  Parsing vulnerable code...")

        vulnerable_ast = self.parser.parse(vulnerable_code)
        if not vulnerable_ast:
            if self.verbose:
                print("    Failed to parse vulnerable code")
            return None

        # Parse patched code
        if self.verbose:
            print("  Parsing patched code...")

        patched_ast = self.parser.parse(patched_code)
        if not patched_ast:
            if self.verbose:
                print("    Failed to parse patched code")
            return None

        # Diff the ASTs
        if self.verbose:
            print("  Computing AST differences...")

        all_diffs = self.differ.diff(vulnerable_ast, patched_ast)

        if self.verbose:
            print(f"    Found {len(all_diffs)} differences")

        # Get minimal diffs (most specific changes)
        minimal_diffs = self.differ.get_minimal_diffs(all_diffs)

        if self.verbose:
            print(f"    Minimal diffs: {len(minimal_diffs)}")

        # Get security-relevant diffs
        security_diffs = self.differ.get_security_relevant_diffs(minimal_diffs)

        if self.verbose:
            print(f"    Security-relevant diffs: {len(security_diffs)}")

        # Use security-relevant diffs if available, otherwise use minimal diffs
        signature_diffs = security_diffs if security_diffs else minimal_diffs

        # Simplify ASTs for storage (reduce size)
        simplified_vuln_ast = self.parser.simplify_ast(vulnerable_ast, max_depth=8)
        simplified_patch_ast = self.parser.simplify_ast(patched_ast, max_depth=8)

        # Create AST signature
        ast_signature = ASTSignature(
            cve=cve,
            plugin_slug=plugin_slug,
            vuln_type=vuln_type,
            title=title,
            wordfence_uuid=wordfence_uuid,
            vulnerable_version=vulnerable_version,
            patched_version=patched_version,
            file_path=file_path,
            vulnerable_ast=simplified_vuln_ast,
            patched_ast=simplified_patch_ast,
            minimal_diffs=signature_diffs,
            vulnerable_code=vulnerable_code,
            patched_code=patched_code,
            references=references
        )

        if self.verbose:
            print("  âœ“ AST signature generated successfully")

        return ast_signature

    def generate_from_unified_diff(
        self,
        cve: Optional[str],
        plugin_slug: str,
        vuln_type: str,
        title: str,
        unified_diff: str,
        vulnerable_version: str = "",
        patched_version: str = "",
        wordfence_uuid: Optional[str] = None,
        references: List[str] = None
    ) -> List[ASTSignature]:
        """
        Generate AST signatures from a unified diff.

        Parses the unified diff to extract pre/post patch code blocks
        for each file, then generates AST signatures for each.

        Args:
            cve: CVE identifier
            plugin_slug: Plugin slug
            vuln_type: Vulnerability type
            title: Vulnerability title
            unified_diff: Unified diff string
            vulnerable_version: Version with vulnerability
            patched_version: Version with patch
            wordfence_uuid: Wordfence UUID
            references: List of reference URLs

        Returns:
            List of ASTSignature objects (one per file in diff)
        """
        if references is None:
            references = []

        signatures = []

        # Parse the unified diff
        file_diffs = self._parse_unified_diff(unified_diff)

        if self.verbose:
            print(f"\nProcessing unified diff for {cve or 'unknown CVE'}")
            print(f"  Found {len(file_diffs)} file(s) changed")

        for file_path, (pre_code, post_code) in file_diffs.items():
            # Only process PHP files
            if not file_path.endswith('.php'):
                if self.verbose:
                    print(f"  Skipping non-PHP file: {file_path}")
                continue

            if self.verbose:
                print(f"  Processing file: {file_path}")

            signature = self.generate_from_code(
                cve=cve,
                plugin_slug=plugin_slug,
                vuln_type=vuln_type,
                title=title,
                vulnerable_code=pre_code,
                patched_code=post_code,
                vulnerable_version=vulnerable_version,
                patched_version=patched_version,
                wordfence_uuid=wordfence_uuid,
                references=references,
                file_path=file_path
            )

            if signature:
                signatures.append(signature)

        return signatures

    def _parse_unified_diff(self, unified_diff: str) -> Dict[str, tuple[str, str]]:
        """
        Parse a unified diff to extract pre/post code for each file.

        Args:
            unified_diff: Unified diff string

        Returns:
            Dictionary mapping file paths to (pre_code, post_code) tuples
        """
        file_diffs = {}
        current_file = None
        pre_lines = []
        post_lines = []

        for line in unified_diff.split('\n'):
            # Check for file header
            if line.startswith('---'):
                # Save previous file if exists
                if current_file and (pre_lines or post_lines):
                    file_diffs[current_file] = (
                        '\n'.join(pre_lines),
                        '\n'.join(post_lines)
                    )

                # Reset for new file
                pre_lines = []
                post_lines = []
                continue

            elif line.startswith('+++'):
                # Extract file path
                parts = line.split()
                if len(parts) >= 2:
                    current_file = parts[1]
                continue

            elif line.startswith('@@'):
                # Hunk header, skip
                continue

            # Process diff lines
            if line.startswith('-') and not line.startswith('---'):
                # Removed line (in pre-patch only)
                pre_lines.append(line[1:])

            elif line.startswith('+') and not line.startswith('+++'):
                # Added line (in post-patch only)
                post_lines.append(line[1:])

            elif line.startswith(' '):
                # Context line (in both)
                pre_lines.append(line[1:])
                post_lines.append(line[1:])

        # Save last file
        if current_file and (pre_lines or post_lines):
            file_diffs[current_file] = (
                '\n'.join(pre_lines),
                '\n'.join(post_lines)
            )

        return file_diffs

    def save_signature(
        self,
        signature: ASTSignature,
        output_dir: Path
    ) -> Path:
        """
        Save an AST signature to disk.

        Args:
            signature: ASTSignature to save
            output_dir: Output directory

        Returns:
            Path to the saved file
        """
        # Create plugin directory
        plugin_dir = output_dir / signature.plugin_slug
        plugin_dir.mkdir(parents=True, exist_ok=True)

        # Generate filename
        identifier = signature.cve if signature.cve else signature.wordfence_uuid
        if not identifier:
            identifier = f"vuln_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        filename = f"{identifier}_ast.json"
        filepath = plugin_dir / filename

        # Save as JSON
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(signature.to_dict(), f, indent=2, ensure_ascii=False)

        if self.verbose:
            print(f"  Saved: {filepath}")

        return filepath

    def load_signature(self, filepath: Path) -> Optional[ASTSignature]:
        """
        Load an AST signature from disk.

        Args:
            filepath: Path to the JSON file

        Returns:
            ASTSignature object, or None if loading fails
        """
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)

            # Reconstruct ASTSignature from dict
            # This is a simplified version - you might want to add full reconstruction
            return ASTSignature(
                cve=data.get('cve'),
                plugin_slug=data['plugin_slug'],
                vuln_type=data['vuln_type'],
                title=data['title'],
                wordfence_uuid=data.get('wordfence_uuid'),
                vulnerable_version=data.get('vulnerable_version', ''),
                patched_version=data.get('patched_version', ''),
                file_path=data.get('file_path', ''),
                vulnerable_code=data.get('vulnerable_code', ''),
                patched_code=data.get('patched_code', ''),
                references=data.get('references', [])
            )

        except Exception as e:
            if self.verbose:
                print(f"Error loading signature from {filepath}: {e}")
            return None
