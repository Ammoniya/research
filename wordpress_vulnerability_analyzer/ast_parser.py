"""
PHP AST Parser using tree-sitter.

This module provides functionality to parse PHP code into Abstract Syntax Trees
using the tree-sitter library with the PHP grammar.
"""

from typing import Optional
import tree_sitter_php as tsphp
from tree_sitter import Language, Parser, Node as TSNode
from wordpress_vulnerability_analyzer.models import ASTNode


class PHPASTParser:
    """
    Parser for PHP code that generates Abstract Syntax Trees.

    Uses tree-sitter with PHP grammar to parse PHP code and convert
    it into our ASTNode data structure for further analysis.
    """

    def __init__(self):
        """Initialize the PHP parser."""
        self.language = Language(tsphp.language_php())
        self.parser = Parser(self.language)

    def parse(self, code: str) -> Optional[ASTNode]:
        """
        Parse PHP code into an AST.

        Args:
            code: PHP source code to parse

        Returns:
            ASTNode representing the root of the AST, or None if parsing fails
        """
        if not code or not code.strip():
            return None

        try:
            # Ensure code is in bytes
            code_bytes = code.encode('utf-8')

            # Parse the code
            tree = self.parser.parse(code_bytes)

            if tree and tree.root_node:
                # Convert tree-sitter node to our ASTNode
                return self._convert_node(tree.root_node, code_bytes)

            return None

        except Exception as e:
            print(f"Error parsing PHP code: {e}")
            return None

    def _convert_node(self, ts_node: TSNode, source_code: bytes) -> ASTNode:
        """
        Convert a tree-sitter node to our ASTNode structure.

        Args:
            ts_node: Tree-sitter node
            source_code: Original source code as bytes

        Returns:
            ASTNode representation
        """
        # Extract node text
        text = source_code[ts_node.start_byte:ts_node.end_byte].decode('utf-8', errors='ignore')

        # Create ASTNode
        ast_node = ASTNode(
            node_type=ts_node.type,
            text=text,
            start_byte=ts_node.start_byte,
            end_byte=ts_node.end_byte,
            start_point=(ts_node.start_point[0], ts_node.start_point[1]),
            end_point=(ts_node.end_point[0], ts_node.end_point[1]),
            field_name=None,  # Will be set by parent if this is a named field
            children=[]
        )

        # Process children and set their field names
        for i in range(ts_node.child_count):
            child = ts_node.children[i]
            child_node = self._convert_node(child, source_code)

            # Try to get field name for this child
            # We check if this child has a field name by iterating through common field names
            field_name = ts_node.field_name_for_child(i)
            if field_name:
                child_node.field_name = field_name

            ast_node.children.append(child_node)

        return ast_node

    def parse_function(self, code: str) -> Optional[ASTNode]:
        """
        Parse a PHP function specifically.

        Wraps the code in minimal PHP tags if needed and extracts
        the function definition node.

        Args:
            code: PHP function code

        Returns:
            ASTNode representing the function, or None if not found
        """
        # Ensure code has PHP tags
        if not code.strip().startswith('<?php'):
            code = f"<?php\n{code}"

        ast = self.parse(code)
        if not ast:
            return None

        # Find the function definition node
        return self._find_function_node(ast)

    def _find_function_node(self, node: ASTNode) -> Optional[ASTNode]:
        """
        Recursively find a function definition node.

        Args:
            node: ASTNode to search

        Returns:
            First function definition found, or None
        """
        if node.node_type in ['function_definition', 'method_declaration']:
            return node

        for child in node.children:
            result = self._find_function_node(child)
            if result:
                return result

        return None

    def parse_class(self, code: str) -> Optional[ASTNode]:
        """
        Parse a PHP class specifically.

        Args:
            code: PHP class code

        Returns:
            ASTNode representing the class, or None if not found
        """
        # Ensure code has PHP tags
        if not code.strip().startswith('<?php'):
            code = f"<?php\n{code}"

        ast = self.parse(code)
        if not ast:
            return None

        # Find the class declaration node
        return self._find_class_node(ast)

    def _find_class_node(self, node: ASTNode) -> Optional[ASTNode]:
        """
        Recursively find a class declaration node.

        Args:
            node: ASTNode to search

        Returns:
            First class declaration found, or None
        """
        if node.node_type == 'class_declaration':
            return node

        for child in node.children:
            result = self._find_class_node(child)
            if result:
                return result

        return None

    def get_changed_functions(self, ast: ASTNode) -> list[ASTNode]:
        """
        Extract all function definitions from an AST.

        Args:
            ast: Root ASTNode to search

        Returns:
            List of function definition nodes
        """
        functions = []
        self._collect_functions(ast, functions)
        return functions

    def _collect_functions(self, node: ASTNode, functions: list[ASTNode]):
        """
        Recursively collect function definition nodes.

        Args:
            node: Current node
            functions: List to append found functions to
        """
        if node.node_type in ['function_definition', 'method_declaration']:
            functions.append(node)

        for child in node.children:
            self._collect_functions(child, functions)

    def simplify_ast(self, node: ASTNode, max_depth: int = 10, current_depth: int = 0) -> ASTNode:
        """
        Simplify an AST by removing irrelevant nodes and limiting depth.

        This is useful for creating smaller signatures focused on
        structural patterns rather than full implementation details.

        Args:
            node: ASTNode to simplify
            max_depth: Maximum depth to preserve
            current_depth: Current depth (used internally)

        Returns:
            Simplified ASTNode
        """
        # Node types to skip (whitespace, comments, etc.)
        skip_types = {'comment', 'text', 'white_space', 'whitespace'}

        # If we've reached max depth, create a leaf node
        if current_depth >= max_depth:
            return ASTNode(
                node_type=node.node_type,
                text="...",  # Truncate text at max depth
                start_byte=node.start_byte,
                end_byte=node.end_byte,
                start_point=node.start_point,
                end_point=node.end_point,
                field_name=node.field_name,
                children=[]
            )

        # Create simplified node
        simplified = ASTNode(
            node_type=node.node_type,
            text=node.text if current_depth < 2 else "",  # Keep text only at top levels
            start_byte=node.start_byte,
            end_byte=node.end_byte,
            start_point=node.start_point,
            end_point=node.end_point,
            field_name=node.field_name,
            children=[]
        )

        # Process children, skipping irrelevant types
        for child in node.children:
            if child.node_type not in skip_types:
                simplified_child = self.simplify_ast(child, max_depth, current_depth + 1)
                simplified.children.append(simplified_child)

        return simplified
