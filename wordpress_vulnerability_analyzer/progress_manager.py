"""Progress tracking and resume functionality."""

import json
import os
from typing import Set, Dict
from datetime import datetime
from pathlib import Path


class ProgressManager:
    """Manages processing progress for resume capability."""

    def __init__(self, progress_file: str):
        """
        Initialize progress manager.

        Args:
            progress_file: Path to progress tracking file
        """
        self.progress_file = progress_file
        self.processed_ids: Set[str] = set()
        self.stats: Dict = {}

    def load(self) -> Set[str]:
        """
        Load progress from file.

        Returns:
            Set[str]: Set of already processed vulnerability IDs
        """
        if not os.path.exists(self.progress_file):
            return set()

        try:
            with open(self.progress_file, 'r') as f:
                data = json.load(f)
                self.processed_ids = set(data.get('processed_ids', []))
                self.stats = data.get('stats', {})
                return self.processed_ids
        except Exception as e:
            print(f"[!] Error loading progress: {e}")
            return set()

    def save(self, processed_ids: Set[str], stats: Dict):
        """
        Save progress to file.

        Args:
            processed_ids: Set of processed vulnerability IDs
            stats: Processing statistics
        """
        self.processed_ids = processed_ids
        self.stats = stats

        try:
            with open(self.progress_file, 'w') as f:
                json.dump({
                    'last_updated': datetime.now().isoformat(),
                    'processed_count': len(processed_ids),
                    'processed_ids': sorted(list(processed_ids)),
                    'stats': stats
                }, f, indent=2)
        except Exception as e:
            print(f"[!] Error saving progress: {e}")

    def is_processed(self, vuln_id: str) -> bool:
        """
        Check if vulnerability has been processed.

        Args:
            vuln_id: Vulnerability ID

        Returns:
            bool: True if already processed
        """
        return vuln_id in self.processed_ids

    def mark_processed(self, vuln_id: str):
        """
        Mark vulnerability as processed.

        Args:
            vuln_id: Vulnerability ID
        """
        self.processed_ids.add(vuln_id)

    def get_stats(self) -> Dict:
        """
        Get current statistics.

        Returns:
            Dict: Statistics dictionary
        """
        return self.stats.copy()


class SignatureStorage:
    """Manages storage of individual signature files."""

    def __init__(self, output_dir: str):
        """
        Initialize signature storage.

        Args:
            output_dir: Directory for signature files
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def save_signature(self, signature) -> str:
        """
        Save signature to individual files (both markdown and JSON).

        Args:
            signature: CodeSignature object

        Returns:
            str: Path to saved markdown file
        """
        # Create plugin directory
        plugin_dir = self.output_dir / signature.plugin_slug
        plugin_dir.mkdir(parents=True, exist_ok=True)

        # Generate base filename
        if signature.cve and signature.cve != 'N/A':
            base_filename = signature.cve
        else:
            # Use hash for non-CVE vulnerabilities
            import hashlib
            hash_id = hashlib.md5(
                f"{signature.vuln_type}:{signature.extracted_at}".encode()
            ).hexdigest()[:12]
            base_filename = f"vuln_{hash_id}"

        # Save as Markdown (for human reading)
        md_filepath = plugin_dir / f"{base_filename}.md"
        with open(md_filepath, 'w') as f:
            f.write(signature.to_markdown())

        # Save as JSON (for programmatic access/statistics)
        json_filepath = plugin_dir / f"{base_filename}.json"
        with open(json_filepath, 'w') as f:
            json.dump(signature.to_dict(), f, indent=2)

        return str(md_filepath)

    def load_all_signatures(self) -> list:
        """
        Load all signatures from directory.

        Returns:
            list: List of signature dictionaries
        """
        signatures = []

        if not self.output_dir.exists():
            return signatures

        for plugin_dir in self.output_dir.iterdir():
            if not plugin_dir.is_dir():
                continue

            for sig_file in plugin_dir.glob("*.json"):
                try:
                    with open(sig_file, 'r') as f:
                        signatures.append(json.load(f))
                except Exception as e:
                    print(f"[!] Error loading {sig_file}: {e}")

        return signatures

    def get_signature_count(self) -> int:
        """
        Get count of stored signatures.

        Returns:
            int: Number of signatures
        """
        count = 0
        if self.output_dir.exists():
            for plugin_dir in self.output_dir.iterdir():
                if plugin_dir.is_dir():
                    count += len(list(plugin_dir.glob("*.json")))
        return count
