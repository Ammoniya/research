"""SVN repository diff extraction."""

import subprocess
import tempfile
import re
from pathlib import Path
from typing import Optional, List, Tuple
from .models import DiffBlock


class SVNDiffExtractor:
    """Extracts code diffs from SVN repositories."""

    def __init__(self, svn_repos_dir: Path, diff_timeout: int = 30):
        """
        Initialize SVN diff extractor.

        Args:
            svn_repos_dir: Base directory containing SVN repositories
            diff_timeout: Timeout for diff operations in seconds
        """
        self.svn_repos_dir = Path(svn_repos_dir)
        self.diff_timeout = diff_timeout

    def get_local_repo_path(self, plugin_slug: str) -> Optional[Path]:
        """
        Get path to local SVN repository.

        Args:
            plugin_slug: Plugin identifier

        Returns:
            Optional[Path]: Path to repository or None
        """
        repo_path = self.svn_repos_dir / plugin_slug
        return repo_path if repo_path.exists() else None

    def get_available_tags(self, plugin_slug: str) -> List[str]:
        """
        Get list of available version tags.

        Args:
            plugin_slug: Plugin identifier

        Returns:
            List[str]: Sorted list of version tags
        """
        repo_path = self.get_local_repo_path(plugin_slug)
        if not repo_path:
            return []

        tags_dir = repo_path / "tags"
        if not tags_dir.exists():
            return []

        tags = [d.name for d in tags_dir.iterdir() if d.is_dir()]
        return sorted(tags, key=self._version_key)

    def _version_key(self, version: str) -> Tuple:
        """
        Convert version string to sortable tuple.

        Args:
            version: Version string

        Returns:
            Tuple: Sortable version tuple
        """
        parts = re.findall(r'\d+', version)
        return tuple(int(p) for p in parts) if parts else (0,)

    def find_vulnerable_and_patched_versions(
        self,
        plugin_slug: str,
        affected_versions: str,
        patched_version: Optional[str]
    ) -> Tuple[Optional[str], Optional[str]]:
        """
        Find the actual vulnerable and patched version tags in SVN.

        Args:
            plugin_slug: Plugin identifier
            affected_versions: Version constraint (e.g., "<= 1.2.3")
            patched_version: Known patched version if available

        Returns:
            Tuple[Optional[str], Optional[str]]: (vulnerable_version, fixed_version)
        """
        available_tags = self.get_available_tags(plugin_slug)
        if not available_tags:
            return None, None

        # Find vulnerable version
        vulnerable_version = self._find_last_vulnerable_version(
            affected_versions, available_tags
        )

        # Find patched version
        if patched_version:
            fixed_version = self._find_closest_tag(patched_version, available_tags)
        else:
            fixed_version = self._find_next_version(vulnerable_version, available_tags)

        return vulnerable_version, fixed_version

    def _find_last_vulnerable_version(
        self,
        constraint: str,
        available_tags: List[str]
    ) -> Optional[str]:
        """Find the last vulnerable version matching the constraint."""
        match = re.search(r'([<>=]+)\s*([\d.]+)', constraint)
        if not match:
            return available_tags[-1] if available_tags else None

        operator, version = match.groups()
        target_key = self._version_key(version)

        candidates = []
        for tag in available_tags:
            tag_key = self._version_key(tag)
            if operator == '<=' and tag_key <= target_key:
                candidates.append(tag)
            elif operator == '<' and tag_key < target_key:
                candidates.append(tag)
            elif operator == '=' and tag_key == target_key:
                candidates.append(tag)

        return candidates[-1] if candidates else None

    def _find_closest_tag(self, version: str, available_tags: List[str]) -> Optional[str]:
        """Find the closest matching tag to a version."""
        target_key = self._version_key(version)

        # Try exact match first
        for tag in available_tags:
            if self._version_key(tag) == target_key:
                return tag

        # Find closest higher version
        for tag in available_tags:
            if self._version_key(tag) >= target_key:
                return tag

        return None

    def _find_next_version(
        self,
        current_version: Optional[str],
        available_tags: List[str]
    ) -> Optional[str]:
        """Find the next version after current version."""
        if not current_version:
            return None

        current_key = self._version_key(current_version)
        for tag in available_tags:
            if self._version_key(tag) > current_key:
                return tag

        return None

    def get_diff_from_local(
        self,
        plugin_slug: str,
        vuln_version: str,
        fixed_version: str
    ) -> Optional[str]:
        """
        Extract diff between two versions from local SVN repo.

        Args:
            plugin_slug: Plugin identifier
            vuln_version: Vulnerable version tag
            fixed_version: Fixed version tag

        Returns:
            Optional[str]: Diff output or None
        """
        repo_path = self.get_local_repo_path(plugin_slug)
        if not repo_path:
            return None

        vuln_path = repo_path / "tags" / vuln_version
        fixed_path = repo_path / "tags" / fixed_version

        if not (vuln_path.exists() and fixed_path.exists()):
            return None

        try:
            result = subprocess.run(
                ['diff', '-ruN', str(vuln_path), str(fixed_path)],
                capture_output=True,
                text=True,
                timeout=self.diff_timeout
            )
            return result.stdout if result.stdout else None
        except subprocess.TimeoutExpired:
            print(f"[!] Timeout diffing {plugin_slug} {vuln_version} -> {fixed_version}")
            return None
        except Exception as e:
            print(f"[!] Error diffing {plugin_slug}: {e}")
            return None

    def parse_diff_to_blocks(self, diff: str) -> List[DiffBlock]:
        """
        Parse unified diff output into structured blocks.

        Args:
            diff: Unified diff output

        Returns:
            List[DiffBlock]: List of diff blocks
        """
        blocks = []
        current_file = None
        current_before = []
        current_after = []
        current_hunks = []
        hunk = None

        for line in diff.split('\n'):
            # File headers
            if line.startswith('--- '):
                # Save previous block
                if current_file and (current_before or current_after):
                    blocks.append(DiffBlock(
                        file_path=current_file,
                        before_code='\n'.join(current_before),
                        after_code='\n'.join(current_after),
                        hunks=current_hunks
                    ))
                    current_before = []
                    current_after = []
                    current_hunks = []

                current_file = line[4:].split('\t')[0]

            # Hunk headers (@@ -10,5 +10,7 @@)
            elif line.startswith('@@'):
                if hunk:
                    current_hunks.append(hunk)
                hunk = {
                    'header': line,
                    'before': [],
                    'after': []
                }

            # Removed lines (in before)
            elif line.startswith('-') and not line.startswith('---'):
                current_before.append(line[1:])
                if hunk:
                    hunk['before'].append(line[1:])

            # Added lines (in after)
            elif line.startswith('+') and not line.startswith('+++'):
                current_after.append(line[1:])
                if hunk:
                    hunk['after'].append(line[1:])

            # Context lines (in both)
            elif hunk and line.startswith(' '):
                hunk['before'].append(line[1:])
                hunk['after'].append(line[1:])

        # Add final hunk
        if hunk:
            current_hunks.append(hunk)

        # Add final block
        if current_file and (current_before or current_after):
            blocks.append(DiffBlock(
                file_path=current_file,
                before_code='\n'.join(current_before),
                after_code='\n'.join(current_after),
                hunks=current_hunks
            ))

        return blocks

    def get_diff_stats(self, diff_blocks: List[DiffBlock]) -> dict:
        """
        Calculate statistics about the diff.

        Args:
            diff_blocks: List of diff blocks

        Returns:
            dict: Statistics including file count, lines added/removed
        """
        stats = {
            'file_changes': len(diff_blocks),
            'php_files': sum(1 for b in diff_blocks if b.is_php_file()),
            'total_lines_added': sum(len(b.get_added_lines()) for b in diff_blocks),
            'total_lines_removed': sum(len(b.get_removed_lines()) for b in diff_blocks),
        }
        return stats
