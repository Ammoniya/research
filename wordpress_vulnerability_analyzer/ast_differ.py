"""
AST Differ - compares two ASTs and identifies minimal differences.

This module provides functionality to compare Abstract Syntax Trees
and identify the minimal differing subtrees that represent the
vulnerability pattern and its fix.
"""

from typing import List, Tuple, Set
from wordpress_vulnerability_analyzer.models import ASTNode, ASTDiff


class ASTDiffer:
    """
    Compares two ASTs and identifies structural differences.

    This class implements algorithms to find minimal differing subtrees
    between vulnerable and patched code ASTs, which form the signature
    of the vulnerability.
    """

    def __init__(self, ignore_whitespace: bool = True, ignore_comments: bool = True):
        """
        Initialize the AST differ.

        Args:
            ignore_whitespace: Whether to ignore whitespace differences
            ignore_comments: Whether to ignore comment differences
        """
        self.ignore_whitespace = ignore_whitespace
        self.ignore_comments = ignore_comments
        self.skip_types = set()

        if ignore_whitespace:
            self.skip_types.update({'whitespace', 'white_space'})
        if ignore_comments:
            self.skip_types.add('comment')

    def diff(self, vulnerable_ast: ASTNode, patched_ast: ASTNode) -> List[ASTDiff]:
        """
        Compare two ASTs and find all differences.

        Args:
            vulnerable_ast: AST of vulnerable code
            patched_ast: AST of patched code

        Returns:
            List of ASTDiff objects representing differences
        """
        diffs = []
        path = []

        self._diff_nodes(vulnerable_ast, patched_ast, path, diffs)

        return diffs

    def _diff_nodes(
        self,
        vuln_node: ASTNode,
        patch_node: ASTNode,
        path: List[str],
        diffs: List[ASTDiff]
    ):
        """
        Recursively compare two nodes and their children.

        Args:
            vuln_node: Node from vulnerable version
            patch_node: Node from patched version
            path: Current path in the tree
            diffs: List to append differences to
        """
        # Add current node type to path
        current_path = path + [vuln_node.node_type if vuln_node else patch_node.node_type]

        # Check if node types differ
        if vuln_node.node_type != patch_node.node_type:
            diffs.append(ASTDiff(
                diff_type='modified',
                vulnerable_node=vuln_node,
                patched_node=patch_node,
                path=current_path,
                description=f"Node type changed: {vuln_node.node_type} -> {patch_node.node_type}"
            ))
            return  # Don't recurse if types differ

        # Filter children by skip types
        vuln_children = [c for c in vuln_node.children if c.node_type not in self.skip_types]
        patch_children = [c for c in patch_node.children if c.node_type not in self.skip_types]

        # Check if structure differs (different number of children)
        if len(vuln_children) != len(patch_children):
            # Find which children were added/removed
            vuln_sigs = {self._node_signature(c): c for c in vuln_children}
            patch_sigs = {self._node_signature(c): c for c in patch_children}

            # Find removed nodes
            for sig, node in vuln_sigs.items():
                if sig not in patch_sigs:
                    diffs.append(ASTDiff(
                        diff_type='removed',
                        vulnerable_node=node,
                        patched_node=None,
                        path=current_path,
                        description=f"Node removed: {node.node_type}"
                    ))

            # Find added nodes
            for sig, node in patch_sigs.items():
                if sig not in vuln_sigs:
                    diffs.append(ASTDiff(
                        diff_type='added',
                        vulnerable_node=None,
                        patched_node=node,
                        path=current_path,
                        description=f"Node added: {node.node_type}"
                    ))

            # Continue with matching children
            for sig in vuln_sigs.keys() & patch_sigs.keys():
                self._diff_nodes(vuln_sigs[sig], patch_sigs[sig], current_path, diffs)

        else:
            # Same number of children, compare them pairwise
            for vuln_child, patch_child in zip(vuln_children, patch_children):
                # Check if the nodes are semantically different
                if not self._nodes_equivalent(vuln_child, patch_child):
                    self._diff_nodes(vuln_child, patch_child, current_path, diffs)

    def _node_signature(self, node: ASTNode) -> str:
        """
        Generate a signature for a node for matching purposes.

        Args:
            node: ASTNode to signature

        Returns:
            String signature
        """
        # Use node type and field name
        sig = node.node_type
        if node.field_name:
            sig = f"{node.field_name}:{sig}"
        return sig

    def _nodes_equivalent(self, node1: ASTNode, node2: ASTNode) -> bool:
        """
        Check if two nodes are semantically equivalent.

        Args:
            node1: First node
            node2: Second node

        Returns:
            True if nodes are equivalent
        """
        # Different types are not equivalent
        if node1.node_type != node2.node_type:
            return False

        # For leaf nodes (no children), compare text
        if not node1.children and not node2.children:
            # Normalize text for comparison
            text1 = node1.text.strip()
            text2 = node2.text.strip()
            return text1 == text2

        # For non-leaf nodes, check structure
        children1 = [c for c in node1.children if c.node_type not in self.skip_types]
        children2 = [c for c in node2.children if c.node_type not in self.skip_types]

        if len(children1) != len(children2):
            return False

        # Check if all children have the same types
        types1 = [c.node_type for c in children1]
        types2 = [c.node_type for c in children2]

        return types1 == types2

    def get_minimal_diffs(self, diffs: List[ASTDiff]) -> List[ASTDiff]:
        """
        Filter to only the most minimal (specific) differences.

        If a parent and child both differ, only keep the child diff
        as it's more specific.

        Args:
            diffs: List of all differences

        Returns:
            List of minimal differences
        """
        if not diffs:
            return []

        # Sort by path length (deeper = more specific)
        sorted_diffs = sorted(diffs, key=lambda d: len(d.path), reverse=True)

        minimal = []
        covered_paths = set()

        for diff in sorted_diffs:
            # Check if this diff is already covered by a more specific one
            path_str = '/'.join(diff.path)

            is_covered = False
            for covered_path in covered_paths:
                if covered_path.startswith(path_str + '/'):
                    is_covered = True
                    break

            if not is_covered:
                minimal.append(diff)
                covered_paths.add(path_str)

        return minimal

    def get_security_relevant_diffs(self, diffs: List[ASTDiff]) -> List[ASTDiff]:
        """
        Filter differences to only security-relevant changes.

        Identifies diffs that involve security functions, input validation,
        authentication, sanitization, etc.

        Args:
            diffs: List of all differences

        Returns:
            List of security-relevant differences
        """
        security_keywords = {
            # WordPress security functions
            'wp_nonce', 'check_admin_referer', 'check_ajax_referer',
            'current_user_can', 'is_admin', 'is_user_logged_in',
            'sanitize_', 'esc_', 'wp_kses',
            'prepare', 'wpdb',
            'wp_verify_nonce',

            # PHP security functions
            'htmlspecialchars', 'htmlentities', 'strip_tags',
            'filter_', 'preg_match', 'preg_replace',
            'password_', 'crypt', 'hash',

            # Dangerous functions
            'eval', 'exec', 'system', 'shell_exec',
            'unserialize', 'file_get_contents', 'file_put_contents',
        }

        security_diffs = []

        for diff in diffs:
            # Check if any security keyword is in the diff text
            vuln_text = diff.vulnerable_node.text if diff.vulnerable_node else ""
            patch_text = diff.patched_node.text if diff.patched_node else ""

            combined_text = (vuln_text + " " + patch_text).lower()

            if any(keyword.lower() in combined_text for keyword in security_keywords):
                security_diffs.append(diff)

        return security_diffs

    def diff_summary(self, diffs: List[ASTDiff]) -> dict:
        """
        Generate a summary of differences.

        Args:
            diffs: List of differences

        Returns:
            Dictionary with summary statistics
        """
        summary = {
            'total_diffs': len(diffs),
            'added': 0,
            'removed': 0,
            'modified': 0,
            'unique_paths': set(),
            'node_types_changed': set()
        }

        for diff in diffs:
            summary[diff.diff_type] += 1
            summary['unique_paths'].add('/'.join(diff.path))

            if diff.vulnerable_node:
                summary['node_types_changed'].add(diff.vulnerable_node.node_type)
            if diff.patched_node:
                summary['node_types_changed'].add(diff.patched_node.node_type)

        # Convert sets to lists for JSON serialization
        summary['unique_paths'] = list(summary['unique_paths'])
        summary['node_types_changed'] = list(summary['node_types_changed'])

        return summary

    def visualize_diff(self, diff: ASTDiff, indent: int = 0) -> str:
        """
        Create a human-readable visualization of a diff.

        Args:
            diff: The difference to visualize
            indent: Current indentation level

        Returns:
            Formatted string representation
        """
        indent_str = "  " * indent
        lines = []

        lines.append(f"{indent_str}[{diff.diff_type.upper()}] {diff.description}")
        lines.append(f"{indent_str}Path: {' -> '.join(diff.path)}")

        if diff.vulnerable_node:
            lines.append(f"{indent_str}Vulnerable:")
            lines.append(f"{indent_str}  {diff.vulnerable_node.node_type}")
            if diff.vulnerable_node.text and len(diff.vulnerable_node.text) < 100:
                lines.append(f"{indent_str}  Text: {diff.vulnerable_node.text[:100]}")

        if diff.patched_node:
            lines.append(f"{indent_str}Patched:")
            lines.append(f"{indent_str}  {diff.patched_node.node_type}")
            if diff.patched_node.text and len(diff.patched_node.text) < 100:
                lines.append(f"{indent_str}  Text: {diff.patched_node.text[:100]}")

        return '\n'.join(lines)
