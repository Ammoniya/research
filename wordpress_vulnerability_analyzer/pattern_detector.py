"""Enhanced pattern detection with context awareness and validation."""

import re
from typing import List, Dict, Set
from .models import DiffBlock, DetectedPattern, PatternCategory


class PatternDetector:
    """Detects security patterns in code diffs with context awareness."""

    # Security function patterns by category
    PATTERNS = {
        PatternCategory.AUTH: [
            r'wp_verify_nonce',
            r'current_user_can',
            r'is_user_logged_in',
            r'check_admin_referer',
            r'check_ajax_referer',
            r'wp_create_nonce',
            r'is_admin',
            r'wp_get_current_user',
            r'get_current_user_id',
        ],
        PatternCategory.SANITIZE: [
            r'sanitize_text_field',
            r'sanitize_email',
            r'sanitize_key',
            r'sanitize_file_name',
            r'sanitize_title',
            r'wp_strip_all_tags',
            r'stripslashes_deep',
            r'wp_kses',
            r'wp_kses_post',
        ],
        PatternCategory.SQL_SECURITY: [
            r'\$wpdb->prepare',
            r'esc_sql',
            r'absint',
            r'intval',
            r'floatval',
            r'doubleval',
        ],
        PatternCategory.FILE_SECURITY: [
            r'validate_file',
            r'wp_check_filetype',
            r'basename',
            r'realpath',
            r'wp_mkdir_p',
            r'wp_upload_dir',
            r'path_is_absolute',
            r'wp_normalize_path',
        ],
        PatternCategory.OUTPUT_ESC: [
            r'esc_html',
            r'esc_attr',
            r'esc_js',
            r'esc_url',
            r'esc_textarea',
        ],
        PatternCategory.CAPABILITY: [
            r'manage_options',
            r'edit_posts',
            r'edit_pages',
            r'delete_posts',
            r'publish_posts',
            r'upload_files',
        ],
    }

    # Dangerous functions (should be removed, not added)
    DANGEROUS_PATTERNS = [
        r'eval\s*\(',
        r'system\s*\(',
        r'exec\s*\(',
        r'passthru\s*\(',
        r'shell_exec\s*\(',
        r'popen\s*\(',
        r'proc_open\s*\(',
        r'unserialize\s*\(',
    ]

    def __init__(self, min_confidence: float = 0.7):
        """
        Initialize pattern detector.

        Args:
            min_confidence: Minimum confidence score to include pattern
        """
        self.min_confidence = min_confidence

    def detect_patterns_in_blocks(
        self,
        diff_blocks: List[DiffBlock]
    ) -> List[DetectedPattern]:
        """
        Detect all security patterns across diff blocks.

        Args:
            diff_blocks: List of diff blocks to analyze

        Returns:
            List[DetectedPattern]: All detected patterns with confidence scores
        """
        all_patterns = []

        for block in diff_blocks:
            # Only analyze PHP files
            if not block.is_php_file():
                continue

            patterns = self._detect_in_block(block)
            all_patterns.extend(patterns)

        # Filter by minimum confidence
        return [p for p in all_patterns if p.confidence >= self.min_confidence]

    def _detect_in_block(self, block: DiffBlock) -> List[DetectedPattern]:
        """
        Detect patterns in a single diff block.

        Args:
            block: Diff block to analyze

        Returns:
            List[DetectedPattern]: Detected patterns
        """
        patterns = []

        # Get only added lines (not in before, but in after)
        added_lines = block.get_added_lines()

        for i, line in enumerate(added_lines):
            # Skip if not actual code
            if not self._is_actual_code(line):
                continue

            # Check for added security patterns
            detected = self._check_line_for_patterns(line, i, added_lines)
            patterns.extend(detected)

        # Check for removed dangerous functions
        removed_lines = block.get_removed_lines()
        for i, line in enumerate(removed_lines):
            if not self._is_actual_code(line):
                continue

            detected = self._check_removed_dangerous(line, i)
            patterns.extend(detected)

        # Check for validation patterns
        validation_patterns = self._detect_validation_patterns(block)
        patterns.extend(validation_patterns)

        return patterns

    def _is_actual_code(self, line: str) -> bool:
        """
        Check if line is actual code (not comment or string literal).

        Args:
            line: Code line to check

        Returns:
            bool: True if line is actual code
        """
        stripped = line.strip()

        # Skip empty lines
        if not stripped:
            return False

        # Skip comments
        if stripped.startswith('//'):
            return False
        if stripped.startswith('/*'):
            return False
        if stripped.startswith('*'):
            return False
        if stripped.startswith('#'):
            return False

        # Skip obvious string literals (basic check)
        if (stripped.startswith('"') and stripped.endswith('"') and
                stripped.count('"') == 2):
            return False
        if (stripped.startswith("'") and stripped.endswith("'") and
                stripped.count("'") == 2):
            return False

        return True

    def _check_line_for_patterns(
        self,
        line: str,
        line_num: int,
        all_lines: List[str]
    ) -> List[DetectedPattern]:
        """
        Check a single line for security patterns.

        Args:
            line: Line to check
            line_num: Line number
            all_lines: All lines for context

        Returns:
            List[DetectedPattern]: Detected patterns
        """
        detected = []

        for category, patterns in self.PATTERNS.items():
            for pattern in patterns:
                if re.search(pattern, line):
                    confidence = self._calculate_confidence(
                        pattern, line, category
                    )

                    detected.append(DetectedPattern(
                        category=category.value,
                        function_name=pattern.replace(r'\s*\(', '').replace('\\$', '$'),
                        confidence=confidence,
                        line_number=line_num,
                        context_lines=self._get_context(all_lines, line_num, 2),
                        in_actual_code=True
                    ))

        return detected

    def _check_removed_dangerous(self, line: str, line_num: int) -> List[DetectedPattern]:
        """
        Check if a dangerous function was removed.

        Args:
            line: Line that was removed
            line_num: Line number

        Returns:
            List[DetectedPattern]: Detected dangerous function removals
        """
        detected = []

        for pattern in self.DANGEROUS_PATTERNS:
            if re.search(pattern, line):
                detected.append(DetectedPattern(
                    category=PatternCategory.REMOVED_DANGEROUS.value,
                    function_name=pattern.replace(r'\s*\(', ''),
                    confidence=0.95,  # High confidence for dangerous function removal
                    line_number=line_num,
                    context_lines=[line],
                    in_actual_code=True
                ))

        return detected

    def _detect_validation_patterns(self, block: DiffBlock) -> List[DetectedPattern]:
        """
        Detect validation patterns (isset, empty, type casting).

        Args:
            block: Diff block to analyze

        Returns:
            List[DetectedPattern]: Detected validation patterns
        """
        patterns = []
        added = block.get_added_lines()
        before_code = block.before_code

        # isset() checks
        isset_matches = re.findall(r'isset\s*\([^)]+\)', '\n'.join(added))
        if isset_matches and 'isset' not in before_code:
            patterns.append(DetectedPattern(
                category='VALIDATION',
                function_name='isset',
                confidence=0.8,
                in_actual_code=True
            ))

        # empty() checks
        empty_matches = re.findall(r'empty\s*\([^)]+\)', '\n'.join(added))
        if empty_matches and 'empty' not in before_code:
            patterns.append(DetectedPattern(
                category='VALIDATION',
                function_name='empty',
                confidence=0.8,
                in_actual_code=True
            ))

        # Type casting
        type_casts = re.findall(r'\(\s*(int|string|bool|float|array)\s*\)', '\n'.join(added))
        for cast_type in set(type_casts):
            if f'({cast_type})' not in before_code:
                patterns.append(DetectedPattern(
                    category='TYPE_CAST',
                    function_name=cast_type.strip(),
                    confidence=0.7,
                    in_actual_code=True
                ))

        return patterns

    def _calculate_confidence(
        self,
        pattern: str,
        line: str,
        category: PatternCategory
    ) -> float:
        """
        Calculate confidence score for a pattern match.

        Higher confidence when:
        - Pattern is in a conditional statement (if, while, etc.)
        - Pattern is assigned to a variable
        - Pattern is in echo/print statement (for output escaping)
        - Pattern is used with proper context

        Args:
            pattern: Regex pattern that matched
            line: Line where pattern was found
            category: Category of pattern

        Returns:
            float: Confidence score (0.0 to 1.0)
        """
        confidence = 0.7  # Base confidence

        line_lower = line.lower().strip()

        # Authentication patterns
        if category == PatternCategory.AUTH:
            # Higher confidence if in conditional
            if any(keyword in line_lower for keyword in ['if ', 'if(', 'while', '!', 'return ']):
                confidence = 0.95
            elif 'function ' in line_lower:
                # Lower confidence if just in function signature
                confidence = 0.5

        # Output escaping patterns
        elif category == PatternCategory.OUTPUT_ESC:
            # Higher confidence if with echo/print
            if any(keyword in line_lower for keyword in ['echo ', 'print ', 'return ']):
                confidence = 0.95
            else:
                confidence = 0.75

        # Sanitization patterns
        elif category == PatternCategory.SANITIZE:
            # Higher confidence if assigned to variable
            if '=' in line and '==' not in line:
                confidence = 0.9
            else:
                confidence = 0.75

        # SQL security patterns
        elif category == PatternCategory.SQL_SECURITY:
            # $wpdb->prepare is very reliable
            if '$wpdb->prepare' in pattern:
                confidence = 0.98
            elif any(func in pattern for func in ['absint', 'intval']):
                confidence = 0.85

        # File security
        elif category == PatternCategory.FILE_SECURITY:
            confidence = 0.85

        return min(confidence, 1.0)

    def _get_context(
        self,
        lines: List[str],
        target_line: int,
        context_size: int
    ) -> List[str]:
        """
        Get surrounding lines for context.

        Args:
            lines: All lines
            target_line: Target line number
            context_size: Number of lines before/after

        Returns:
            List[str]: Context lines
        """
        start = max(0, target_line - context_size)
        end = min(len(lines), target_line + context_size + 1)
        return lines[start:end]

    def categorize_patterns(
        self,
        patterns: List[DetectedPattern],
        vuln_type: str
    ) -> Dict[str, List[DetectedPattern]]:
        """
        Categorize patterns as primary or incidental.

        Primary patterns = match the vulnerability type
        Incidental patterns = other security improvements

        Args:
            patterns: All detected patterns
            vuln_type: Vulnerability type string

        Returns:
            Dict with 'primary' and 'incidental' pattern lists
        """
        # Map vulnerability types to expected pattern categories
        vuln_pattern_map = {
            'CSRF': [PatternCategory.AUTH.value],
            'Cross-Site Request Forgery': [PatternCategory.AUTH.value],
            'Missing Authorization': [PatternCategory.AUTH.value, 'CAPABILITY'],
            'XSS': [PatternCategory.SANITIZE.value, PatternCategory.OUTPUT_ESC.value],
            'Cross-Site Scripting': [PatternCategory.SANITIZE.value, PatternCategory.OUTPUT_ESC.value],
            'SQL Injection': [PatternCategory.SQL_SECURITY.value],
            'Path Traversal': [PatternCategory.FILE_SECURITY.value],
            'File Inclusion': [PatternCategory.FILE_SECURITY.value],
            'Remote Code Execution': [PatternCategory.REMOVED_DANGEROUS.value],
        }

        # Find expected categories for this vulnerability
        expected_categories = []
        for vuln_keyword, categories in vuln_pattern_map.items():
            if vuln_keyword in vuln_type:
                expected_categories.extend(categories)

        # Categorize
        primary = []
        incidental = []

        for pattern in patterns:
            if pattern.category in expected_categories:
                primary.append(pattern)
            else:
                incidental.append(pattern)

        return {
            'primary': primary,
            'incidental': incidental
        }
