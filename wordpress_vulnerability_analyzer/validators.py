"""Validation logic for signatures."""

from typing import List, Tuple
from .models import CodeSignature, DetectedPattern, DiffBlock


class SignatureValidator:
    """Validates extracted signatures for quality and accuracy."""

    def __init__(self):
        """Initialize validator."""
        self.validation_rules = [
            self._validate_pattern_count,
            self._validate_diff_size,
            self._validate_confidence,
            self._validate_pattern_relevance,
        ]

    def validate(self, signature: CodeSignature, diff_blocks: List[DiffBlock]) -> Tuple[bool, List[str]]:
        """
        Validate a signature.

        Args:
            signature: Signature to validate
            diff_blocks: Original diff blocks

        Returns:
            Tuple[bool, List[str]]: (is_valid, list_of_notes)
        """
        notes = []

        for rule in self.validation_rules:
            valid, rule_notes = rule(signature, diff_blocks)
            notes.extend(rule_notes)

        # Signature is valid if no critical issues found
        critical_issues = [n for n in notes if n.startswith('[CRITICAL]')]
        is_valid = len(critical_issues) == 0

        signature.validated = is_valid
        signature.validation_notes = notes

        return is_valid, notes

    def _validate_pattern_count(
        self,
        signature: CodeSignature,
        diff_blocks: List[DiffBlock]
    ) -> Tuple[bool, List[str]]:
        """Validate pattern count is reasonable."""
        notes = []
        all_patterns = signature.get_all_patterns()

        if len(all_patterns) == 0:
            notes.append("[CRITICAL] No patterns detected")
            return False, notes

        if len(all_patterns) == 1:
            notes.append("[INFO] Single pattern signature (high confidence)")

        if len(all_patterns) > 5:
            notes.append("[WARNING] Many patterns detected - may indicate complex fix or false positives")

        return True, notes

    def _validate_diff_size(
        self,
        signature: CodeSignature,
        diff_blocks: List[DiffBlock]
    ) -> Tuple[bool, List[str]]:
        """Validate diff size is reasonable."""
        notes = []
        file_count = signature.diff_stats.get('file_changes', 0)

        if file_count == 0:
            notes.append("[CRITICAL] No file changes detected")
            return False, notes

        if file_count > 10:
            notes.append(
                f"[WARNING] Large diff ({file_count} files) - "
                "higher risk of unrelated code"
            )

        if file_count > 50:
            notes.append(
                "[CRITICAL] Very large diff - likely includes unrelated changes"
            )
            return False, notes

        return True, notes

    def _validate_confidence(
        self,
        signature: CodeSignature,
        diff_blocks: List[DiffBlock]
    ) -> Tuple[bool, List[str]]:
        """Validate confidence is reasonable."""
        notes = []

        # Check exploitability score
        if signature.exploitability_score >= 8.0:
            notes.append("[INFO] High exploitability score - critical vulnerability")
        elif signature.exploitability_score < 3.0:
            notes.append("[WARNING] Low exploitability score - may not be significant")

        # Check if high-confidence signature
        if signature.is_high_confidence():
            notes.append(
                "[INFO] High-confidence signature: "
                "single pattern, matches vuln type, small diff"
            )

        return True, notes

    def _validate_pattern_relevance(
        self,
        signature: CodeSignature,
        diff_blocks: List[DiffBlock]
    ) -> Tuple[bool, List[str]]:
        """Validate patterns are relevant to vulnerability type."""
        notes = []

        if len(signature.primary_patterns) == 0:
            notes.append(
                "[WARNING] No primary patterns match vulnerability type - "
                "may be misclassified"
            )

        if len(signature.incidental_patterns) > len(signature.primary_patterns):
            notes.append(
                "[INFO] More incidental than primary patterns - "
                "multiple issues fixed together"
            )

        return True, notes

    def calculate_quality_score(self, signature: CodeSignature) -> float:
        """
        Calculate overall quality score for signature.

        Score based on:
        - Pattern count (1 is best)
        - Diff size (smaller is better)
        - Primary vs incidental ratio
        - Validation notes

        Args:
            signature: Signature to score

        Returns:
            float: Quality score (0.0 to 1.0)
        """
        score = 1.0

        # Deduct for multiple patterns (ambiguity)
        pattern_count = len(signature.get_all_patterns())
        if pattern_count > 1:
            score -= 0.1 * (pattern_count - 1)

        # Deduct for large diffs
        file_count = signature.diff_stats.get('file_changes', 1)
        if file_count > 5:
            score -= 0.05 * (file_count - 5)

        # Bonus for high-confidence
        if signature.is_high_confidence():
            score += 0.2

        # Deduct for warnings in validation notes
        warning_count = sum(1 for n in signature.validation_notes if '[WARNING]' in n)
        score -= 0.1 * warning_count

        # Deduct heavily for critical issues
        critical_count = sum(1 for n in signature.validation_notes if '[CRITICAL]' in n)
        score -= 0.5 * critical_count

        return max(0.0, min(1.0, score))
