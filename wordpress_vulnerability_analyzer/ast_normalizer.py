"""
AST Normalizer - normalizes AST nodes to create reusable vulnerability patterns.

This module removes plugin-specific details from AST nodes, creating
normalized patterns that can match similar vulnerabilities across different codebases.
"""

import re
from typing import Dict, Set, Optional
from wordpress_vulnerability_analyzer.models import ASTNode


class ASTNormalizer:
    """
    Normalizes AST nodes by removing incidental details.

    This class transforms AST nodes into normalized patterns by:
    - Replacing variable names with placeholders ($VAR1, $VAR2, etc.)
    - Optionally fuzzing string literals
    - Removing line number information
    - Sorting where order doesn't matter
    """

    def __init__(
        self,
        normalize_vars: bool = True,
        normalize_strings: bool = False,
        normalize_function_names: bool = False
    ):
        """
        Initialize the normalizer.

        Args:
            normalize_vars: Replace variable names with $VAR1, $VAR2, etc.
            normalize_strings: Replace string literals with STRING1, STRING2, etc.
            normalize_function_names: Replace function names with FUNC1, FUNC2, etc.
        """
        self.normalize_vars = normalize_vars
        self.normalize_strings = normalize_strings
        self.normalize_function_names = normalize_function_names

        # Mapping dictionaries for normalization
        self.var_mapping: Dict[str, str] = {}
        self.var_counter = 0

        self.string_mapping: Dict[str, str] = {}
        self.string_counter = 0

        self.func_mapping: Dict[str, str] = {}
        self.func_counter = 0

        # Security-relevant functions to preserve (don't normalize)
        self.security_functions = {
            # WordPress security functions
            'esc_html', 'esc_attr', 'esc_url', 'esc_js', 'esc_textarea',
            'esc_sql', 'wp_kses', 'wp_kses_post', 'sanitize_text_field',
            'sanitize_email', 'sanitize_file_name', 'sanitize_key',
            'sanitize_title', 'wp_nonce_field', 'wp_verify_nonce',
            'check_admin_referer', 'check_ajax_referer', 'current_user_can',
            'is_admin', 'is_user_logged_in', 'absint', 'intval',

            # PHP security functions
            'htmlspecialchars', 'htmlentities', 'strip_tags',
            'filter_var', 'filter_input', 'preg_match', 'preg_replace',
            'password_hash', 'password_verify', 'hash', 'hash_equals',

            # Dangerous functions (important to detect)
            'eval', 'exec', 'system', 'shell_exec', 'passthru',
            'unserialize', 'file_get_contents', 'file_put_contents',
            'fopen', 'fwrite', 'require', 'include', 'require_once',
            'include_once',

            # Database functions
            'prepare', 'query', 'get_var', 'get_results'
        }

    def normalize(self, node: ASTNode) -> Dict:
        """
        Normalize an AST node into a pattern dictionary.

        Args:
            node: AST node to normalize

        Returns:
            Dictionary representing normalized pattern
        """
        # Reset mappings for each normalization
        self.var_mapping = {}
        self.var_counter = 0
        self.string_mapping = {}
        self.string_counter = 0
        self.func_mapping = {}
        self.func_counter = 0

        return self._normalize_node(node)

    def _normalize_node(self, node: ASTNode) -> Dict:
        """
        Recursively normalize a node.

        Args:
            node: Node to normalize

        Returns:
            Normalized dictionary representation
        """
        normalized = {
            'type': node.node_type,
        }

        # Handle field name if present
        if node.field_name:
            normalized['field'] = node.field_name

        # Normalize based on node type
        if node.node_type == 'variable_name':
            # Normalize variable names
            if self.normalize_vars:
                var_name = node.text.strip()
                if var_name not in self.var_mapping:
                    self.var_counter += 1
                    self.var_mapping[var_name] = f"$VAR{self.var_counter}"
                normalized['value'] = self.var_mapping[var_name]
                normalized['normalized'] = True
            else:
                normalized['value'] = node.text.strip()

        elif node.node_type in ('string', 'string_value', 'encapsed_string'):
            # Normalize string literals
            if self.normalize_strings:
                string_val = node.text.strip()
                if string_val not in self.string_mapping:
                    self.string_counter += 1
                    self.string_mapping[string_val] = f"STRING{self.string_counter}"
                normalized['value'] = self.string_mapping[string_val]
                normalized['normalized'] = True
                normalized['fuzzy'] = True
            else:
                normalized['value'] = node.text.strip()

        elif node.node_type == 'name' or node.node_type == 'function_call_expression':
            # Check if it's a function name
            func_name = node.text.strip()

            # Don't normalize security-relevant functions
            if func_name.lower() in self.security_functions:
                normalized['value'] = func_name
                normalized['security_relevant'] = True
            elif self.normalize_function_names:
                if func_name not in self.func_mapping:
                    self.func_counter += 1
                    self.func_mapping[func_name] = f"FUNC{self.func_counter}"
                normalized['value'] = self.func_mapping[func_name]
                normalized['normalized'] = True
            else:
                normalized['value'] = func_name

        elif not node.children:
            # Leaf node - include text
            text = node.text.strip()
            if text:
                normalized['value'] = text

        # Recursively normalize children
        if node.children:
            normalized['children'] = []
            for child in node.children:
                # Skip whitespace and comment nodes
                if child.node_type not in ('comment', 'text_interpolation', 'text'):
                    normalized_child = self._normalize_node(child)
                    normalized['children'].append(normalized_child)

        return normalized

    def create_pattern_signature(
        self,
        vuln_node: ASTNode,
        patch_node: Optional[ASTNode] = None
    ) -> Dict:
        """
        Create a complete pattern signature from vulnerable and patched nodes.

        Args:
            vuln_node: Vulnerable version node
            patch_node: Patched version node (optional)

        Returns:
            Pattern signature dictionary
        """
        signature = {
            'vulnerable_pattern': self.normalize(vuln_node),
        }

        if patch_node:
            # Reset mappings for patched version
            # But keep same variable mappings for consistency
            saved_var_mapping = self.var_mapping.copy()
            saved_var_counter = self.var_counter

            signature['patched_pattern'] = self.normalize(patch_node)

            # Note: The mappings might be different between vuln and patch
            # That's OK - we're showing the transformation

        # Add metadata about the pattern
        signature['pattern_type'] = self._infer_pattern_type(vuln_node, patch_node)

        return signature

    def _infer_pattern_type(
        self,
        vuln_node: ASTNode,
        patch_node: Optional[ASTNode]
    ) -> str:
        """
        Infer the type of vulnerability pattern.

        Args:
            vuln_node: Vulnerable node
            patch_node: Patched node

        Returns:
            Pattern type string
        """
        vuln_text = vuln_node.text.lower()
        patch_text = patch_node.text.lower() if patch_node else ''

        # Check for common patterns
        if 'echo' in vuln_text and any(esc in patch_text for esc in ['esc_', 'htmlspecialchars']):
            return 'missing_output_escaping'

        if '$_' in vuln_text and any(san in patch_text for san in ['sanitize_', 'filter_']):
            return 'missing_input_sanitization'

        if 'prepare' not in vuln_text and 'prepare' in patch_text:
            return 'sql_injection'

        if 'wp_verify_nonce' in patch_text and 'wp_verify_nonce' not in vuln_text:
            return 'missing_nonce_verification'

        if 'current_user_can' in patch_text and 'current_user_can' not in vuln_text:
            return 'missing_capability_check'

        if 'unserialize' in vuln_text:
            return 'unsafe_deserialization'

        # Default
        return 'security_function_missing'

    def get_security_functions_in_node(self, node: ASTNode) -> Set[str]:
        """
        Extract all security-relevant functions used in a node.

        Args:
            node: AST node to analyze

        Returns:
            Set of security function names found
        """
        functions = set()

        text = node.text.lower()
        for func in self.security_functions:
            if func in text:
                functions.add(func)

        return functions

    def compare_security_functions(
        self,
        vuln_node: ASTNode,
        patch_node: ASTNode
    ) -> Dict[str, Set[str]]:
        """
        Compare security functions between vulnerable and patched versions.

        Args:
            vuln_node: Vulnerable version node
            patch_node: Patched version node

        Returns:
            Dictionary with 'added', 'removed', 'common' sets of functions
        """
        vuln_funcs = self.get_security_functions_in_node(vuln_node)
        patch_funcs = self.get_security_functions_in_node(patch_node)

        return {
            'added': patch_funcs - vuln_funcs,
            'removed': vuln_funcs - patch_funcs,
            'common': vuln_funcs & patch_funcs
        }

    def create_detection_rule(
        self,
        vuln_pattern: Dict,
        metadata: Dict = None
    ) -> Dict:
        """
        Create a detection rule from a vulnerability pattern.

        Args:
            vuln_pattern: Normalized vulnerable pattern
            metadata: Additional metadata (CVE, description, etc.)

        Returns:
            Detection rule dictionary
        """
        rule = {
            'pattern': vuln_pattern,
            'match_type': 'structural',  # Could be 'exact', 'fuzzy', 'structural'
        }

        if metadata:
            rule['metadata'] = metadata

        # Add matching hints
        hints = []

        def extract_hints(pattern):
            """Extract matching hints from pattern."""
            if isinstance(pattern, dict):
                if pattern.get('security_relevant'):
                    hints.append({
                        'type': 'missing_function',
                        'function': pattern.get('value')
                    })

                if pattern.get('type') == 'variable_name' and not pattern.get('normalized'):
                    hints.append({
                        'type': 'suspicious_variable',
                        'name': pattern.get('value')
                    })

                if 'children' in pattern:
                    for child in pattern['children']:
                        extract_hints(child)

        extract_hints(vuln_pattern)
        if hints:
            rule['hints'] = hints

        return rule
