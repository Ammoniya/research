"""Temporal tracking of vulnerability patterns."""

import json
import os
from typing import List, Dict, Optional
from datetime import datetime
from collections import defaultdict

from .models import (
    PatternMatch,
    PluginTimeline,
    VulnerabilityClone,
    FixStatus
)


class TemporalTracker:
    """Tracks vulnerability patterns over time."""

    def __init__(self, output_dir: str):
        """
        Initialize temporal tracker.

        Args:
            output_dir: Directory for timeline outputs
        """
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)

    def build_timeline(
        self,
        plugin_slug: str,
        signature_id: str,
        pattern: str,
        matches: List[Dict]
    ) -> PluginTimeline:
        """
        Build timeline from pattern matches.

        Args:
            plugin_slug: Plugin slug
            signature_id: Signature ID
            pattern: Pattern string
            matches: List of match dictionaries

        Returns:
            PluginTimeline: Constructed timeline
        """
        if not matches:
            return PluginTimeline(
                plugin_slug=plugin_slug,
                signature_id=signature_id,
                pattern=pattern
            )

        # Sort matches by revision date
        sorted_matches = sorted(
            matches,
            key=lambda m: m.get('revision_date', ''),
            reverse=False
        )

        # Build timeline
        timeline = PluginTimeline(
            plugin_slug=plugin_slug,
            signature_id=signature_id,
            pattern=pattern
        )

        # First appearance
        first_match = sorted_matches[0]
        timeline.first_appearance = self._parse_datetime(first_match.get('revision_date'))
        timeline.first_appearance_revision = first_match.get('revision')

        # Last appearance
        last_match = sorted_matches[-1]
        timeline.last_appearance = self._parse_datetime(last_match.get('revision_date'))
        timeline.last_appearance_revision = last_match.get('revision')

        # Total revisions with pattern
        timeline.total_revisions_with_pattern = len(set(
            m.get('revision') for m in matches
        ))

        # Calculate persistence
        timeline.calculate_persistence_days()

        return timeline

    def determine_fix_status(
        self,
        timeline: PluginTimeline,
        known_cves: List[str],
        current_version_vulnerable: bool
    ) -> FixStatus:
        """
        Determine fix status for a timeline.

        Args:
            timeline: Plugin timeline
            known_cves: List of known CVEs for this plugin
            current_version_vulnerable: Whether current version is vulnerable

        Returns:
            FixStatus: Determined fix status
        """
        if current_version_vulnerable:
            return FixStatus.STILL_VULNERABLE

        # Check if signature_id is a known CVE
        if timeline.signature_id in known_cves:
            return FixStatus.FIXED_WITH_CVE

        # If fixed but no CVE, it's a silent fix
        if timeline.last_appearance and not current_version_vulnerable:
            return FixStatus.FIXED_SILENTLY

        return FixStatus.UNKNOWN

    def build_vulnerability_clone(
        self,
        signature_id: str,
        original_cve: Optional[str],
        original_plugin: str,
        vulnerability_type: str,
        pattern: str,
        timelines: List[PluginTimeline]
    ) -> VulnerabilityClone:
        """
        Build vulnerability clone from timelines.

        Args:
            signature_id: Signature ID
            original_cve: Original CVE (if any)
            original_plugin: Plugin where vulnerability originated
            vulnerability_type: Type of vulnerability
            pattern: Pattern string
            timelines: List of plugin timelines

        Returns:
            VulnerabilityClone: Vulnerability clone object
        """
        clone = VulnerabilityClone(
            signature_id=signature_id,
            original_cve=original_cve,
            original_plugin=original_plugin,
            vulnerability_type=vulnerability_type,
            pattern=pattern,
            timelines=timelines
        )

        # Calculate statistics
        clone.calculate_statistics()

        # Build inheritance tree
        clone.inheritance_tree = self._build_inheritance_tree(timelines)

        # Determine patient zero
        clone.patient_zero = self._determine_patient_zero(timelines)

        return clone

    def _build_inheritance_tree(
        self,
        timelines: List[PluginTimeline]
    ) -> Dict[str, List[str]]:
        """
        Build inheritance tree showing pattern spreading.

        Args:
            timelines: List of timelines

        Returns:
            Dict[str, List[str]]: Inheritance relationships
        """
        # Sort timelines by first appearance
        sorted_timelines = sorted(
            timelines,
            key=lambda t: t.first_appearance or datetime.max
        )

        inheritance = defaultdict(list)

        # Simple heuristic: earlier plugins potentially infected later ones
        for i, timeline in enumerate(sorted_timelines):
            # Look at plugins that appeared later
            for later_timeline in sorted_timelines[i+1:]:
                # If appeared within 6 months, consider potential inheritance
                if (timeline.first_appearance and
                    later_timeline.first_appearance):

                    delta = later_timeline.first_appearance - timeline.first_appearance
                    if delta.days < 180:  # 6 months
                        inheritance[timeline.plugin_slug].append(
                            later_timeline.plugin_slug
                        )

        return dict(inheritance)

    def _determine_patient_zero(
        self,
        timelines: List[PluginTimeline]
    ) -> Optional[str]:
        """
        Determine patient zero (first plugin with pattern).

        Args:
            timelines: List of timelines

        Returns:
            Optional[str]: Plugin slug of patient zero
        """
        if not timelines:
            return None

        # Find timeline with earliest first appearance
        earliest = min(
            timelines,
            key=lambda t: t.first_appearance or datetime.max
        )

        if earliest.first_appearance:
            return earliest.plugin_slug

        return None

    def save_timeline(self, timeline: PluginTimeline):
        """
        Save timeline to file.

        Args:
            timeline: Timeline to save
        """
        filename = f"{timeline.plugin_slug}_{timeline.signature_id}.json"
        filepath = os.path.join(self.output_dir, filename)

        with open(filepath, 'w') as f:
            json.dump(timeline.to_dict(), f, indent=2)

    def save_vulnerability_clone(self, clone: VulnerabilityClone):
        """
        Save vulnerability clone to file.

        Args:
            clone: Vulnerability clone to save
        """
        filename = f"clone_{clone.signature_id}.json"
        filepath = os.path.join(self.output_dir, filename)

        with open(filepath, 'w') as f:
            json.dump(clone.to_dict(), f, indent=2)

    def load_all_timelines(self) -> List[PluginTimeline]:
        """
        Load all saved timelines.

        Returns:
            List[PluginTimeline]: All timelines
        """
        timelines = []

        for filename in os.listdir(self.output_dir):
            if not filename.endswith('.json') or filename.startswith('clone_'):
                continue

            filepath = os.path.join(self.output_dir, filename)
            try:
                with open(filepath, 'r') as f:
                    data = json.load(f)
                    # Reconstruct timeline from dict (simplified)
                    timeline = PluginTimeline(
                        plugin_slug=data['plugin_slug'],
                        signature_id=data['signature_id'],
                        pattern=data['pattern'],
                        first_appearance=self._parse_datetime(data.get('first_appearance')),
                        last_appearance=self._parse_datetime(data.get('last_appearance')),
                        fix_status=FixStatus(data.get('fix_status', 'unknown')),
                        currently_vulnerable=data.get('currently_vulnerable', False),
                        persistence_days=data.get('persistence_days', 0)
                    )
                    timelines.append(timeline)
            except Exception as e:
                print(f"Error loading timeline {filename}: {e}")

        return timelines

    def _parse_datetime(self, dt_str: Optional[str]) -> Optional[datetime]:
        """
        Parse datetime string.

        Args:
            dt_str: Datetime string

        Returns:
            Optional[datetime]: Parsed datetime or None
        """
        if not dt_str:
            return None

        try:
            return datetime.fromisoformat(dt_str.replace('Z', '+00:00'))
        except:
            return None

    def analyze_silent_fixes(
        self,
        timelines: List[PluginTimeline]
    ) -> Dict[str, any]:
        """
        Analyze silent fix patterns.

        Args:
            timelines: List of timelines

        Returns:
            Dict: Analysis results
        """
        total_fixes = sum(
            1 for t in timelines
            if t.fix_status in [FixStatus.FIXED_WITH_CVE, FixStatus.FIXED_SILENTLY]
        )

        silent_fixes = sum(
            1 for t in timelines
            if t.fix_status == FixStatus.FIXED_SILENTLY
        )

        silent_fix_rate = (silent_fixes / total_fixes * 100) if total_fixes > 0 else 0

        return {
            'total_fixes': total_fixes,
            'silent_fixes': silent_fixes,
            'cve_fixes': total_fixes - silent_fixes,
            'silent_fix_rate': round(silent_fix_rate, 2),
            'examples': [
                t.to_dict() for t in timelines
                if t.fix_status == FixStatus.FIXED_SILENTLY
            ][:10]  # First 10 examples
        }

    def calculate_vulnerability_half_life(
        self,
        timelines: List[PluginTimeline]
    ) -> float:
        """
        Calculate median persistence duration (vulnerability half-life).

        Args:
            timelines: List of timelines

        Returns:
            float: Median persistence in days
        """
        persistence_days = [
            t.persistence_days for t in timelines
            if t.persistence_days > 0
        ]

        if not persistence_days:
            return 0.0

        sorted_days = sorted(persistence_days)
        n = len(sorted_days)

        if n % 2 == 0:
            return (sorted_days[n//2 - 1] + sorted_days[n//2]) / 2
        else:
            return sorted_days[n//2]
