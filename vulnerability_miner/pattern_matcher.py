"""Pattern matching engine for vulnerability signatures."""

import re
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from .models import PatternMatch, MatchType
from datetime import datetime


@dataclass
class SignaturePattern:
    """Represents a parsed signature pattern."""

    signature_id: str
    vuln_type: str
    pattern_string: str
    categories: Dict[str, List[str]]  # e.g., {'AUTH': ['wp_verify_nonce'], ...}
    exploitability_score: float = 0.0


class PatternMatcher:
    """Matches vulnerability patterns in code."""

    def __init__(self, min_confidence: float = 0.7):
        """
        Initialize pattern matcher.

        Args:
            min_confidence: Minimum confidence for matches
        """
        self.min_confidence = min_confidence
        self._compiled_patterns = {}  # Cache for compiled regex patterns

    def parse_signature(self, signature: dict) -> Optional[SignaturePattern]:
        """
        Parse a signature from the signature database.

        Args:
            signature: Signature dictionary

        Returns:
            Optional[SignaturePattern]: Parsed signature or None
        """
        try:
            pattern_string = signature.get('pattern', '')

            # Parse pattern: "VulnType::CAT1[func1,func2]|CAT2[func3]"
            categories = self._parse_pattern_string(pattern_string)

            return SignaturePattern(
                signature_id=signature.get('cve') or signature.get('wordfence_uuid', ''),
                vuln_type=signature.get('vuln_type', ''),
                pattern_string=pattern_string,
                categories=categories,
                exploitability_score=signature.get('exploitability_score', 0.0)
            )

        except Exception as e:
            print(f"Error parsing signature: {e}")
            return None

    def _parse_pattern_string(self, pattern_string: str) -> Dict[str, List[str]]:
        """
        Parse pattern string into categories and functions.

        Args:
            pattern_string: Pattern string like "CSRF::AUTH[wp_verify_nonce]"

        Returns:
            Dict[str, List[str]]: Categories and their functions
        """
        categories = {}

        # Split by "::" to get vuln_type::patterns
        if '::' not in pattern_string:
            return categories

        _, patterns_part = pattern_string.split('::', 1)

        # Split by "|" to get individual category patterns
        category_patterns = patterns_part.split('|')

        for cat_pattern in category_patterns:
            # Parse "CATEGORY[func1,func2]"
            match = re.match(r'([A-Z_]+)\[(.*?)\]', cat_pattern.strip())
            if match:
                category = match.group(1)
                functions = [f.strip() for f in match.group(2).split(',')]
                categories[category] = functions

        return categories

    def find_pattern_in_code(
        self,
        code: str,
        signature_pattern: SignaturePattern,
        file_path: str = ""
    ) -> List[Dict]:
        """
        Find vulnerability pattern in code.

        Args:
            code: PHP code to search
            signature_pattern: Parsed signature pattern
            file_path: File path for context

        Returns:
            List[Dict]: List of matches found
        """
        matches = []

        # Search for each function in each category
        for category, functions in signature_pattern.categories.items():
            for function_name in functions:
                function_matches = self._find_function_in_code(
                    code,
                    function_name,
                    category,
                    file_path,
                    signature_pattern
                )
                matches.extend(function_matches)

        return matches

    def _get_compiled_pattern(self, function_name: str) -> re.Pattern:
        """
        Get or create compiled regex pattern for a function.

        Args:
            function_name: Function name

        Returns:
            re.Pattern: Compiled regex pattern
        """
        if function_name not in self._compiled_patterns:
            # Create regex pattern for function
            if function_name.startswith('$'):
                # Database functions like $wpdb->prepare
                pattern_str = re.escape(function_name)
            else:
                # Regular functions
                pattern_str = r'\b' + re.escape(function_name) + r'\s*\('

            self._compiled_patterns[function_name] = re.compile(pattern_str)

        return self._compiled_patterns[function_name]

    def _find_function_in_code(
        self,
        code: str,
        function_name: str,
        category: str,
        file_path: str,
        signature_pattern: SignaturePattern
    ) -> List[Dict]:
        """
        Find specific function in code.

        Args:
            code: Code to search
            function_name: Function to find
            category: Pattern category
            file_path: File path
            signature_pattern: Signature pattern

        Returns:
            List[Dict]: Matches found
        """
        matches = []
        lines = code.split('\n')

        # Get compiled pattern (cached)
        pattern = self._get_compiled_pattern(function_name)

        for line_num, line in enumerate(lines, 1):
            # Skip comments and strings
            if not self._is_actual_code(line):
                continue

            if pattern.search(line):
                # Calculate confidence based on context
                confidence = self._calculate_match_confidence(
                    line,
                    function_name,
                    category,
                    lines,
                    line_num
                )

                if confidence >= self.min_confidence:
                    matches.append({
                        'function': function_name,
                        'category': category,
                        'line_number': line_num,
                        'line_content': line.strip(),
                        'confidence': confidence,
                        'file_path': file_path,
                        'signature_id': signature_pattern.signature_id,
                        'match_type': MatchType.EXACT
                    })

        return matches

    def _is_actual_code(self, line: str) -> bool:
        """
        Check if line is actual code (not comment or string).

        Args:
            line: Line to check

        Returns:
            bool: True if actual code
        """
        stripped = line.strip()

        if not stripped:
            return False

        # Skip comments
        if stripped.startswith('//'):
            return False
        if stripped.startswith('/*'):
            return False
        if stripped.startswith('*'):
            return False
        if stripped.startswith('#'):
            return False

        return True

    def _calculate_match_confidence(
        self,
        line: str,
        function_name: str,
        category: str,
        all_lines: List[str],
        line_num: int
    ) -> float:
        """
        Calculate confidence score for a match.

        Args:
            line: Matched line
            function_name: Function name
            category: Pattern category
            all_lines: All code lines
            line_num: Line number

        Returns:
            float: Confidence score
        """
        confidence = 0.7  # Base confidence

        line_lower = line.lower()

        # Authentication patterns
        if category == 'AUTH':
            if any(kw in line_lower for kw in ['if ', 'if(', 'while', '!', 'return ']):
                confidence = 0.95
            elif 'function ' in line_lower:
                confidence = 0.5

        # Output escaping
        elif category == 'OUTPUT_ESC':
            if any(kw in line_lower for kw in ['echo ', 'print ', 'return ']):
                confidence = 0.95
            else:
                confidence = 0.75

        # Sanitization
        elif category == 'SANITIZE':
            if '=' in line and '==' not in line:
                confidence = 0.9
            else:
                confidence = 0.75

        # SQL security
        elif category == 'SQL_SECURITY':
            if '$wpdb->prepare' in function_name:
                confidence = 0.98
            elif any(func in function_name for func in ['absint', 'intval']):
                confidence = 0.85

        # File security
        elif category == 'FILE_SECURITY':
            confidence = 0.85

        # Check for negative indicators (function in comment)
        context_lines = self._get_context_lines(all_lines, line_num, 2)
        for ctx_line in context_lines:
            if ctx_line.strip().startswith('//') or ctx_line.strip().startswith('*'):
                confidence *= 0.5

        return min(confidence, 1.0)

    def _get_context_lines(
        self,
        lines: List[str],
        target_line: int,
        context_size: int
    ) -> List[str]:
        """
        Get surrounding lines for context.

        Args:
            lines: All lines
            target_line: Target line number (1-indexed)
            context_size: Number of lines before/after

        Returns:
            List[str]: Context lines
        """
        start = max(0, target_line - context_size - 1)
        end = min(len(lines), target_line + context_size)
        return lines[start:end]

    def check_for_negative_patterns(
        self,
        code: str,
        signature_pattern: SignaturePattern
    ) -> bool:
        """
        Check if code has patterns that indicate it's NOT vulnerable.

        For example, if we're looking for missing wp_verify_nonce,
        but the code already has it, then it's not vulnerable.

        Args:
            code: Code to check
            signature_pattern: Signature pattern

        Returns:
            bool: True if negative patterns found (not vulnerable)
        """
        # For authentication patterns, check if auth is already present
        if 'AUTH' in signature_pattern.categories:
            auth_functions = signature_pattern.categories['AUTH']
            for auth_func in auth_functions:
                if auth_func in code:
                    # Has authentication, likely not vulnerable
                    return True

        # For sanitization, check if sanitization is present
        if 'SANITIZE' in signature_pattern.categories:
            sanitize_functions = signature_pattern.categories['SANITIZE']
            for san_func in sanitize_functions:
                if san_func in code:
                    return True

        return False

    def compare_code_similarity(self, code1: str, code2: str) -> float:
        """
        Compare similarity between two code snippets.

        Args:
            code1: First code snippet
            code2: Second code snippet

        Returns:
            float: Similarity score (0.0-1.0)
        """
        # Simple token-based similarity
        tokens1 = set(re.findall(r'\w+', code1.lower()))
        tokens2 = set(re.findall(r'\w+', code2.lower()))

        if not tokens1 or not tokens2:
            return 0.0

        intersection = tokens1 & tokens2
        union = tokens1 | tokens2

        return len(intersection) / len(union) if union else 0.0

    def is_exact_clone(
        self,
        code: str,
        original_vulnerable_code: str,
        threshold: float = 0.9
    ) -> bool:
        """
        Check if code is an exact clone of vulnerable code.

        Args:
            code: Code to check
            original_vulnerable_code: Original vulnerable code
            threshold: Similarity threshold

        Returns:
            bool: True if exact clone
        """
        similarity = self.compare_code_similarity(code, original_vulnerable_code)
        return similarity >= threshold

    def load_signatures(self, signatures_dir: str) -> List[SignaturePattern]:
        """
        Load all signatures from directory.

        Args:
            signatures_dir: Directory containing signature files

        Returns:
            List[SignaturePattern]: Loaded signatures
        """
        import os
        import json

        signatures = []

        # Walk through signatures directory
        for root, dirs, files in os.walk(signatures_dir):
            for file in files:
                if file.endswith('.json'):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r') as f:
                            sig_data = json.load(f)
                            parsed = self.parse_signature(sig_data)
                            if parsed:
                                signatures.append(parsed)
                    except Exception as e:
                        print(f"Error loading signature {file_path}: {e}")

        return signatures
