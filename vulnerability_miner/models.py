"""Data models for vulnerability mining system."""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set
from datetime import datetime
from enum import Enum


class MatchType(Enum):
    """Type of pattern match."""
    EXACT = "exact"  # Exact code match
    AST = "ast"  # Abstract syntax tree match
    SEMANTIC = "semantic"  # Semantic equivalence


class FixStatus(Enum):
    """Status of vulnerability fix."""
    STILL_VULNERABLE = "still_vulnerable"
    FIXED_WITH_CVE = "fixed_with_cve"
    FIXED_SILENTLY = "fixed_silently"
    UNKNOWN = "unknown"


@dataclass
class PatternMatch:
    """Represents a pattern match in a plugin revision."""

    plugin_slug: str
    revision: int
    revision_date: datetime
    signature_id: str  # CVE or UUID from original vulnerability
    pattern: str  # The matched pattern
    match_type: MatchType
    confidence: float

    # Location in code
    file_path: str
    line_number: int
    matched_code: str

    # Context
    function_name: Optional[str] = None
    class_name: Optional[str] = None

    # Metadata
    is_exact_clone: bool = False
    similarity_score: float = 0.0  # 0.0-1.0

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            'plugin_slug': self.plugin_slug,
            'revision': self.revision,
            'revision_date': self.revision_date.isoformat() if self.revision_date else None,
            'signature_id': self.signature_id,
            'pattern': self.pattern,
            'match_type': self.match_type.value,
            'confidence': self.confidence,
            'file_path': self.file_path,
            'line_number': self.line_number,
            'matched_code': self.matched_code,
            'function_name': self.function_name,
            'class_name': self.class_name,
            'is_exact_clone': self.is_exact_clone,
            'similarity_score': self.similarity_score,
        }


@dataclass
class PluginTimeline:
    """Timeline of vulnerability pattern in a plugin."""

    plugin_slug: str
    signature_id: str
    pattern: str

    # Timeline events
    first_appearance: Optional[datetime] = None
    first_appearance_revision: Optional[int] = None
    last_appearance: Optional[datetime] = None
    last_appearance_revision: Optional[int] = None
    fix_date: Optional[datetime] = None
    fix_revision: Optional[int] = None

    # Status
    fix_status: FixStatus = FixStatus.UNKNOWN
    currently_vulnerable: bool = False

    # Statistics
    total_revisions_with_pattern: int = 0
    persistence_days: int = 0

    # All matches in chronological order
    all_matches: List[PatternMatch] = field(default_factory=list)

    def calculate_persistence_days(self):
        """Calculate how long the pattern persisted."""
        if self.first_appearance and self.last_appearance:
            delta = self.last_appearance - self.first_appearance
            self.persistence_days = delta.days

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            'plugin_slug': self.plugin_slug,
            'signature_id': self.signature_id,
            'pattern': self.pattern,
            'first_appearance': self.first_appearance.isoformat() if self.first_appearance else None,
            'first_appearance_revision': self.first_appearance_revision,
            'last_appearance': self.last_appearance.isoformat() if self.last_appearance else None,
            'last_appearance_revision': self.last_appearance_revision,
            'fix_date': self.fix_date.isoformat() if self.fix_date else None,
            'fix_revision': self.fix_revision,
            'fix_status': self.fix_status.value,
            'currently_vulnerable': self.currently_vulnerable,
            'total_revisions_with_pattern': self.total_revisions_with_pattern,
            'persistence_days': self.persistence_days,
            'match_count': len(self.all_matches),
        }


@dataclass
class VulnerabilityClone:
    """Represents a vulnerability pattern clone across the ecosystem."""

    signature_id: str
    original_cve: Optional[str]
    original_plugin: str
    vulnerability_type: str
    pattern: str

    # Clones found
    total_clones: int = 0
    affected_plugins: Set[str] = field(default_factory=set)
    timelines: List[PluginTimeline] = field(default_factory=list)

    # Statistics
    still_vulnerable_count: int = 0
    fixed_with_cve_count: int = 0
    fixed_silently_count: int = 0

    # Temporal stats
    avg_persistence_days: float = 0.0
    max_persistence_days: int = 0
    min_persistence_days: int = 0

    # Inheritance tracking
    inheritance_tree: Dict[str, List[str]] = field(default_factory=dict)  # plugin -> copied_to
    patient_zero: Optional[str] = None  # First plugin with this pattern

    def calculate_statistics(self):
        """Calculate aggregate statistics."""
        self.total_clones = len(self.timelines)
        self.affected_plugins = set(t.plugin_slug for t in self.timelines)

        self.still_vulnerable_count = sum(
            1 for t in self.timelines if t.currently_vulnerable
        )
        self.fixed_with_cve_count = sum(
            1 for t in self.timelines if t.fix_status == FixStatus.FIXED_WITH_CVE
        )
        self.fixed_silently_count = sum(
            1 for t in self.timelines if t.fix_status == FixStatus.FIXED_SILENTLY
        )

        persistence_days = [t.persistence_days for t in self.timelines if t.persistence_days > 0]
        if persistence_days:
            self.avg_persistence_days = sum(persistence_days) / len(persistence_days)
            self.max_persistence_days = max(persistence_days)
            self.min_persistence_days = min(persistence_days)

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            'signature_id': self.signature_id,
            'original_cve': self.original_cve,
            'original_plugin': self.original_plugin,
            'vulnerability_type': self.vulnerability_type,
            'pattern': self.pattern,
            'total_clones': self.total_clones,
            'affected_plugins': list(self.affected_plugins),
            'still_vulnerable_count': self.still_vulnerable_count,
            'fixed_with_cve_count': self.fixed_with_cve_count,
            'fixed_silently_count': self.fixed_silently_count,
            'avg_persistence_days': round(self.avg_persistence_days, 2),
            'max_persistence_days': self.max_persistence_days,
            'min_persistence_days': self.min_persistence_days,
            'patient_zero': self.patient_zero,
            'timelines': [t.to_dict() for t in self.timelines],
        }


@dataclass
class ResearchMetrics:
    """Research metrics for vulnerability pattern analysis."""

    signature_id: str
    vulnerability_type: str

    # Core metrics
    vpp: float = 0.0  # Vulnerability Pattern Prevalence (%)
    ppd: float = 0.0  # Pattern Persistence Duration (days average)
    sfr: float = 0.0  # Silent Fix Rate (%)
    ew: int = 0  # Exploitability Window (total days across all plugins)

    # Supporting data
    total_plugins_scanned: int = 0
    plugins_with_pattern: int = 0
    total_fixes: int = 0
    silent_fixes: int = 0

    # Temporal data
    earliest_appearance: Optional[datetime] = None
    latest_appearance: Optional[datetime] = None
    pattern_lifespan_days: int = 0

    def calculate_vpp(self):
        """Calculate Vulnerability Pattern Prevalence."""
        if self.total_plugins_scanned > 0:
            self.vpp = (self.plugins_with_pattern / self.total_plugins_scanned) * 100

    def calculate_sfr(self):
        """Calculate Silent Fix Rate."""
        if self.total_fixes > 0:
            self.sfr = (self.silent_fixes / self.total_fixes) * 100

    def calculate_pattern_lifespan(self):
        """Calculate pattern lifespan."""
        if self.earliest_appearance and self.latest_appearance:
            delta = self.latest_appearance - self.earliest_appearance
            self.pattern_lifespan_days = delta.days

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            'signature_id': self.signature_id,
            'vulnerability_type': self.vulnerability_type,
            'vpp': round(self.vpp, 4),
            'ppd': round(self.ppd, 2),
            'sfr': round(self.sfr, 2),
            'ew': self.ew,
            'total_plugins_scanned': self.total_plugins_scanned,
            'plugins_with_pattern': self.plugins_with_pattern,
            'total_fixes': self.total_fixes,
            'silent_fixes': self.silent_fixes,
            'earliest_appearance': self.earliest_appearance.isoformat() if self.earliest_appearance else None,
            'latest_appearance': self.latest_appearance.isoformat() if self.latest_appearance else None,
            'pattern_lifespan_days': self.pattern_lifespan_days,
        }


@dataclass
class ZeroDayFinding:
    """Represents a potential zero-day vulnerability discovery."""

    plugin_slug: str
    current_version: str
    signature_id: str
    original_cve: Optional[str]
    vulnerability_type: str
    pattern: str

    # Match details
    confidence: float
    matched_files: List[str] = field(default_factory=list)
    matched_code_snippets: List[str] = field(default_factory=list)

    # Risk assessment
    exploitability_score: float = 0.0
    has_public_exploit: bool = False
    is_exact_clone: bool = False

    # Metadata
    discovered_date: datetime = field(default_factory=datetime.now)
    verified: bool = False
    reported: bool = False

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            'plugin_slug': self.plugin_slug,
            'current_version': self.current_version,
            'signature_id': self.signature_id,
            'original_cve': self.original_cve,
            'vulnerability_type': self.vulnerability_type,
            'pattern': self.pattern,
            'confidence': self.confidence,
            'matched_files': self.matched_files,
            'matched_code_snippets': self.matched_code_snippets,
            'exploitability_score': self.exploitability_score,
            'has_public_exploit': self.has_public_exploit,
            'is_exact_clone': self.is_exact_clone,
            'discovered_date': self.discovered_date.isoformat(),
            'verified': self.verified,
            'reported': self.reported,
        }


@dataclass
class ProcessingStats:
    """Statistics for mining operations."""

    total_plugins: int = 0
    plugins_processed: int = 0
    plugins_with_matches: int = 0
    total_signatures_searched: int = 0
    total_matches_found: int = 0
    total_zero_days_found: int = 0

    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    elapsed_seconds: float = 0.0

    def calculate_elapsed(self):
        """Calculate elapsed time."""
        if self.start_time and self.end_time:
            delta = self.end_time - self.start_time
            self.elapsed_seconds = delta.total_seconds()

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            'total_plugins': self.total_plugins,
            'plugins_processed': self.plugins_processed,
            'plugins_with_matches': self.plugins_with_matches,
            'total_signatures_searched': self.total_signatures_searched,
            'total_matches_found': self.total_matches_found,
            'total_zero_days_found': self.total_zero_days_found,
            'elapsed_seconds': round(self.elapsed_seconds, 2),
        }
