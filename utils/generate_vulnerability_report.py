#!/usr/bin/env python3
"""
Vulnerability Report Generator

Generates detailed Markdown reports for WordPress plugin vulnerabilities,
including full code diffs showing vulnerable vs. patched code.
"""

import json
import sys
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List

# Import centralized data paths
sys.path.insert(0, str(Path(__file__).parent.parent))
from data_paths import OUTPUT_REPORTS_DIR


class VulnerabilityReportGenerator:
    """Generates formatted vulnerability reports with code diffs."""

    def __init__(self, output_dir: str = None):
        """Initialize the report generator.

        Args:
            output_dir: Directory to save generated reports (defaults to centralized reports directory)
        """
        self.output_dir = Path(output_dir) if output_dir else OUTPUT_REPORTS_DIR
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_report(self, vuln_data: Dict[str, Any]) -> str:
        """Generate a Markdown report for a vulnerability.

        Args:
            vuln_data: Dictionary containing vulnerability information

        Returns:
            Path to the generated report file
        """
        cve = vuln_data.get('cve', 'UNKNOWN')
        plugin_slug = vuln_data.get('plugin_slug', 'unknown-plugin')

        # Create report filename
        report_filename = f"{plugin_slug}_{cve}_report.md"
        report_path = self.output_dir / report_filename

        # Generate report content
        content = self._format_report(vuln_data)

        # Write report
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(content)

        return str(report_path)

    def _format_report(self, vuln_data: Dict[str, Any]) -> str:
        """Format vulnerability data into Markdown report.

        Args:
            vuln_data: Dictionary containing vulnerability information

        Returns:
            Formatted Markdown string
        """
        cve = vuln_data.get('cve', 'UNKNOWN')
        plugin_slug = vuln_data.get('plugin_slug', 'unknown-plugin')
        title = vuln_data.get('context', {}).get('title', 'No title available')
        vuln_type = vuln_data.get('vuln_type', 'Unknown')

        # Start building report
        sections = []

        # Header
        sections.append(f"# Vulnerability Report: {cve}\n")
        sections.append(f"**Plugin:** {plugin_slug}\n")
        sections.append(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        sections.append("---\n")

        # Overview
        sections.append("## Overview\n")
        sections.append(f"**Title:** {title}\n")
        sections.append(f"**CVE ID:** {cve}\n")
        sections.append(f"**Vulnerability Type:** {vuln_type}\n")

        context = vuln_data.get('context', {})
        if 'affected_versions' in context:
            sections.append(f"**Affected Versions:** {context['affected_versions']}\n")
        if 'patched_version' in context:
            sections.append(f"**Patched Version:** {context['patched_version']}\n")
        if 'wordfence_uuid' in context:
            sections.append(f"**Wordfence UUID:** {context['wordfence_uuid']}\n")

        sections.append("")

        # Severity Indicators (exploitability_score and quality_score are not stored in signatures)
        severity_indicators = vuln_data.get('severity_indicators', [])
        if severity_indicators:
            sections.append("## Severity Information\n")
            sections.append("**Severity Indicators:**\n")
            for indicator in severity_indicators:
                sections.append(f"- `{indicator}`\n")
            sections.append("")

        # Detected Patterns
        sections.append("## Detected Patterns\n")

        detected_patterns = context.get('detected_patterns', [])
        if detected_patterns:
            sections.append("**All Detected Patterns:**\n")
            for pattern in detected_patterns:
                sections.append(f"- `{pattern}`\n")
        else:
            sections.append("No patterns detected.\n")

        sections.append("")

        primary_patterns = vuln_data.get('primary_patterns', [])
        if primary_patterns:
            sections.append("**Primary Patterns (vulnerability-specific):**\n")
            for pattern in primary_patterns:
                sections.append(f"- `{pattern}`\n")
            sections.append("")

        incidental_patterns = vuln_data.get('incidental_patterns', [])
        if incidental_patterns:
            sections.append("**Incidental Patterns (general security):**\n")
            for pattern in incidental_patterns:
                sections.append(f"- `{pattern}`\n")
            sections.append("")

        # Signature Pattern
        signature_pattern = vuln_data.get('pattern', '')
        if signature_pattern:
            sections.append("## Signature Pattern\n")
            sections.append(f"```\n{signature_pattern}\n```\n")
            sections.append("")

        # Note: validation_notes are not stored in signature files (internal use only)

        # Code Changes
        diff_stats = vuln_data.get('diff_stats', {})
        if diff_stats:
            sections.append("## Code Changes Statistics\n")
            sections.append(f"- **Files Changed:** {diff_stats.get('file_changes', 'N/A')}\n")
            sections.append(f"- **PHP Files:** {diff_stats.get('php_files', 'N/A')}\n")
            sections.append(f"- **Lines Added:** {diff_stats.get('total_lines_added', 'N/A')}\n")
            sections.append(f"- **Lines Removed:** {diff_stats.get('total_lines_removed', 'N/A')}\n")
            sections.append("")

        # Unified Diff (Git-style)
        unified_diff = vuln_data.get('unified_diff', '')
        if unified_diff:
            sections.append("## Unified Diff (Git-style)\n")
            sections.append("```diff\n")
            sections.append(unified_diff)
            sections.append("\n```\n")
            sections.append("")

        # Code Diffs - The most important part
        sections.append("## Code Differences\n")
        sections.append("This section shows the actual code changes between the vulnerable and patched versions.\n")
        sections.append("")

        diff_before = vuln_data.get('diff_before', '')
        diff_after = vuln_data.get('diff_after', '')

        if diff_before or diff_after:
            # Parse and format the diffs
            before_sections = self._parse_diff_content(diff_before)
            after_sections = self._parse_diff_content(diff_after)

            # Display before code
            if before_sections:
                sections.append("### Vulnerable Code (Before Patch)\n")
                for file_path, code in before_sections:
                    sections.append(f"#### File: `{file_path}`\n")
                    sections.append("```php\n")
                    sections.append(code)
                    sections.append("\n```\n")
                sections.append("")

            # Display after code
            if after_sections:
                sections.append("### Patched Code (After Patch)\n")
                for file_path, code in after_sections:
                    sections.append(f"#### File: `{file_path}`\n")
                    sections.append("```php\n")
                    sections.append(code)
                    sections.append("\n```\n")
                sections.append("")

            # Side-by-side comparison summary
            if before_sections and after_sections:
                sections.append("### Key Changes Summary\n")
                sections.append(self._generate_change_summary(before_sections, after_sections))
                sections.append("")
        else:
            sections.append("*No code diff available*\n")
            sections.append("")

        # Footer
        sections.append("---\n")
        sections.append(f"*Report extracted at: {vuln_data.get('extracted_at', 'Unknown')}*\n")

        return "\n".join(sections)

    def _parse_diff_content(self, diff_content: str) -> List[tuple]:
        """Parse diff content into file sections.

        Args:
            diff_content: Raw diff content string

        Returns:
            List of tuples (file_path, code_content)
        """
        if not diff_content:
            return []

        sections = []
        current_file = None
        current_code = []

        for line in diff_content.split('\n'):
            if line.startswith('File: '):
                # Save previous section
                if current_file and current_code:
                    sections.append((current_file, '\n'.join(current_code)))

                # Start new section
                current_file = line.replace('File: ', '').strip()
                current_code = []
            else:
                if current_file:
                    current_code.append(line)

        # Save last section
        if current_file and current_code:
            sections.append((current_file, '\n'.join(current_code)))

        return sections

    def _generate_change_summary(self, before_sections: List[tuple], after_sections: List[tuple]) -> str:
        """Generate a summary of key changes between before and after.

        Args:
            before_sections: List of (file_path, code) tuples from before
            after_sections: List of (file_path, code) tuples from after

        Returns:
            Formatted summary string
        """
        before_files = {path for path, _ in before_sections}
        after_files = {path for path, _ in after_sections}

        common_files = before_files & after_files

        summary = []
        summary.append(f"**Files modified:** {len(common_files)}\n")

        for file_path in sorted(common_files):
            # Get code for this file from before and after
            before_code = next((code for path, code in before_sections if path == file_path), '')
            after_code = next((code for path, code in after_sections if path == file_path), '')

            # Simple line count comparison
            before_lines = len(before_code.split('\n'))
            after_lines = len(after_code.split('\n'))

            summary.append(f"- `{file_path}`: {before_lines} lines → {after_lines} lines\n")

        return "".join(summary)


def main():
    """Main entry point for the report generator."""
    if len(sys.argv) < 2:
        print("Usage: python generate_vulnerability_report.py <vulnerability_json_file>")
        print("   OR: python generate_vulnerability_report.py --stdin")
        sys.exit(1)

    # Read vulnerability data
    if sys.argv[1] == '--stdin':
        vuln_data = json.load(sys.stdin)
    else:
        json_file = sys.argv[1]
        with open(json_file, 'r') as f:
            vuln_data = json.load(f)

    # Generate report
    generator = VulnerabilityReportGenerator()
    report_path = generator.generate_report(vuln_data)

    print(f"✓ Report generated: {report_path}")


if __name__ == '__main__':
    main()
