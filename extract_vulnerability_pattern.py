#!/usr/bin/env python3
"""
Extract Vulnerability Patterns by Matching AST Signatures

This script compares vulnerability AST signatures against plugin ASTs to find
potentially vulnerable code patterns.

Workflow:
1. Load vulnerability patterns from data/output/signatures/ (CVE signatures with AST)
2. Load plugin ASTs from data/output/ast_signatures/{plugin}-{version}/
3. Compare ASTs to find matches
4. Output results to vulnerability_matches/{plugin}-{version}/

Usage:
    python extract_vulnerability_pattern.py [--signatures DIR] [--ast-signatures DIR] [--output-dir DIR]
"""

import sys
import json
import argparse
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from collections import defaultdict
from datetime import datetime

# Add package to path
sys.path.insert(0, str(Path(__file__).parent))

from wordpress_vulnerability_analyzer.ast_parser import PHPASTParser
from wordpress_vulnerability_analyzer.models import ASTNode


class VulnerabilityMatcher:
    """
    Matches vulnerability patterns against plugin ASTs to find vulnerable code.
    """

    def __init__(self, verbose: bool = True):
        """Initialize the matcher."""
        self.verbose = verbose
        self.parser = PHPASTParser()
        self.stats = {
            'vulnerability_patterns_loaded': 0,
            'plugins_scanned': 0,
            'files_scanned': 0,
            'matches_found': 0,
            'high_confidence_matches': 0
        }

    def log(self, message: str):
        """Print log message if verbose."""
        if self.verbose:
            print(message)

    def load_vulnerability_patterns(self, signatures_dir: Path) -> Dict[str, List[Dict]]:
        """
        Load all vulnerability patterns from signature files.

        Args:
            signatures_dir: Directory containing CVE signature files

        Returns:
            Dictionary mapping plugin_slug to list of vulnerability patterns
        """
        patterns_by_plugin = defaultdict(list)

        if not signatures_dir.exists():
            self.log(f"[!] Signatures directory not found: {signatures_dir}")
            return patterns_by_plugin

        # Load signature files (CVE-*.json or vuln_*.json)
        signature_files = list(signatures_dir.rglob('CVE-*.json')) + list(signatures_dir.rglob('vuln_*.json'))
        self.log(f"[*] Found {len(signature_files)} vulnerability signature files")

        for sig_file in signature_files:
            try:
                with open(sig_file, 'r', encoding='utf-8') as f:
                    signature = json.load(f)

                plugin_slug = signature.get('plugin_slug')
                if not plugin_slug:
                    continue

                # Extract AST signatures if present
                ast_signatures = signature.get('ast_signatures', [])

                if ast_signatures:
                    # Create pattern from signature
                    pattern = {
                        'metadata': {
                            'cve': signature.get('cve'),
                            'plugin_slug': plugin_slug,
                            'vuln_type': signature.get('vuln_type'),
                            'title': signature.get('title'),
                            'vulnerable_version': signature.get('vulnerable_version'),
                            'patched_version': signature.get('patched_version'),
                            'wordfence_uuid': signature.get('wordfence_uuid')
                        },
                        'ast_signatures': ast_signatures
                    }
                    patterns_by_plugin[plugin_slug].append(pattern)
                    self.stats['vulnerability_patterns_loaded'] += 1

            except Exception as e:
                self.log(f"[!] Error loading signature {sig_file}: {e}")

        self.log(f"[+] Loaded {self.stats['vulnerability_patterns_loaded']} vulnerability patterns")
        self.log(f"[+] Covering {len(patterns_by_plugin)} plugins")

        return patterns_by_plugin

    def load_plugin_asts(self, plugin_dir: Path) -> Dict[str, Dict]:
        """
        Load all AST files for a plugin.

        Args:
            plugin_dir: Directory containing plugin AST files

        Returns:
            Dictionary mapping file path to AST data
        """
        asts = {}

        if not plugin_dir.exists():
            return asts

        # Load all JSON files except summary
        ast_files = [f for f in plugin_dir.glob('*.json') if f.name != '_summary.json']

        for ast_file in ast_files:
            try:
                with open(ast_file, 'r', encoding='utf-8') as f:
                    ast_data = json.load(f)

                file_path = ast_data.get('file_path', ast_file.stem)
                asts[file_path] = ast_data
                self.stats['files_scanned'] += 1
            except Exception as e:
                self.log(f"[!] Error loading AST {ast_file}: {e}")

        return asts

    def compare_ast_nodes(self, vuln_node: Dict, plugin_node: Dict, max_depth: int = 5) -> Tuple[bool, float]:
        """
        Compare two AST nodes for similarity.

        Args:
            vuln_node: Vulnerability pattern AST node
            plugin_node: Plugin AST node
            max_depth: Maximum depth to compare

        Returns:
            Tuple of (is_match, confidence_score)
        """
        if max_depth <= 0:
            return True, 0.5

        # Check node type
        if vuln_node.get('type') != plugin_node.get('type'):
            return False, 0.0

        confidence = 1.0

        # Compare text (for leaf nodes)
        vuln_text = vuln_node.get('text', '').strip()
        plugin_text = plugin_node.get('text', '').strip()

        if vuln_text and plugin_text:
            if vuln_text == plugin_text:
                confidence *= 1.0
            elif vuln_text.lower() == plugin_text.lower():
                confidence *= 0.9
            else:
                # Check for partial match
                if vuln_text in plugin_text or plugin_text in vuln_text:
                    confidence *= 0.7
                else:
                    return False, 0.0

        # Compare children
        vuln_children = vuln_node.get('children', [])
        plugin_children = plugin_node.get('children', [])

        if len(vuln_children) != len(plugin_children):
            # Allow some flexibility in child count
            if abs(len(vuln_children) - len(plugin_children)) > 2:
                return False, 0.0
            confidence *= 0.8

        # Compare child nodes
        child_matches = 0
        min_children = min(len(vuln_children), len(plugin_children))

        for i in range(min_children):
            child_match, child_conf = self.compare_ast_nodes(
                vuln_children[i],
                plugin_children[i],
                max_depth - 1
            )
            if child_match:
                child_matches += 1
                confidence *= child_conf

        if min_children > 0:
            match_ratio = child_matches / min_children
            if match_ratio < 0.5:
                return False, 0.0
            confidence *= match_ratio

        # Threshold for considering a match
        is_match = confidence >= 0.6

        return is_match, confidence

    def find_vulnerable_patterns_in_ast(
        self,
        vuln_pattern: Dict,
        plugin_ast: Dict
    ) -> List[Dict]:
        """
        Find instances of a vulnerability pattern in a plugin AST.

        Args:
            vuln_pattern: Vulnerability pattern to search for
            plugin_ast: Plugin AST to search in

        Returns:
            List of matches with confidence scores
        """
        matches = []

        # Get AST signatures from pattern (multiple possible patterns)
        ast_signatures = vuln_pattern.get('ast_signatures', [])
        if not ast_signatures:
            return matches

        # Get plugin AST
        plugin_ast_tree = plugin_ast.get('ast')
        if not plugin_ast_tree:
            return matches

        # Try each AST signature pattern
        for ast_sig in ast_signatures:
            vuln_ast = ast_sig.get('vulnerable_pattern', {}).get('ast')
            if not vuln_ast:
                continue

            # Search for pattern in plugin AST
            def search_node(node: Dict, path: str = "") -> None:
                # Try to match at this node
                is_match, confidence = self.compare_ast_nodes(vuln_ast, node)

                if is_match:
                    match_info = {
                        'confidence': confidence,
                        'path': path,
                        'node_type': node.get('type'),
                        'pattern_type': ast_sig.get('pattern_type', 'unknown'),
                        'is_high_confidence': confidence >= 0.8
                    }
                    matches.append(match_info)

                # Recursively search children
                for i, child in enumerate(node.get('children', [])):
                    child_path = f"{path}/{child.get('type', 'unknown')}[{i}]"
                    search_node(child, child_path)

            search_node(plugin_ast_tree, "root")

        return matches

    def match_plugin_against_patterns(
        self,
        plugin_slug: str,
        version: str,
        ast_dir: Path,
        vulnerability_patterns: List[Dict]
    ) -> Dict:
        """
        Match a plugin against vulnerability patterns.

        Args:
            plugin_slug: Plugin slug
            version: Plugin version
            ast_dir: Directory containing plugin AST files
            vulnerability_patterns: List of vulnerability patterns to check

        Returns:
            Dictionary containing match results
        """
        self.log(f"\n[*] Scanning {plugin_slug} {version}")
        self.log(f"    [*] Checking against {len(vulnerability_patterns)} vulnerability patterns")

        # Load plugin ASTs
        plugin_asts = self.load_plugin_asts(ast_dir)

        if not plugin_asts:
            self.log(f"    [!] No AST files found")
            return None

        self.log(f"    [+] Loaded {len(plugin_asts)} AST files")

        # Check each vulnerability pattern
        all_matches = []

        for vuln_pattern in vulnerability_patterns:
            cve = vuln_pattern.get('metadata', {}).get('cve', 'Unknown')
            vuln_type = vuln_pattern.get('metadata', {}).get('vuln_type', 'Unknown')

            self.log(f"    [*] Checking for {cve} ({vuln_type})")

            pattern_matches = []

            # Check each file
            for file_path, plugin_ast in plugin_asts.items():
                file_matches = self.find_vulnerable_patterns_in_ast(vuln_pattern, plugin_ast)

                if file_matches:
                    pattern_matches.append({
                        'file': file_path,
                        'matches': file_matches
                    })

            if pattern_matches:
                total_matches = sum(len(fm['matches']) for fm in pattern_matches)
                high_conf = sum(
                    1 for fm in pattern_matches
                    for m in fm['matches']
                    if m['is_high_confidence']
                )

                self.log(f"        [+] Found {total_matches} matches ({high_conf} high-confidence)")

                match_result = {
                    'cve': cve,
                    'vulnerability_type': vuln_type,
                    'title': vuln_pattern.get('metadata', {}).get('title', ''),
                    'vulnerable_version': vuln_pattern.get('metadata', {}).get('vulnerable_version'),
                    'patched_version': vuln_pattern.get('metadata', {}).get('patched_version'),
                    'total_matches': total_matches,
                    'high_confidence_matches': high_conf,
                    'file_matches': pattern_matches,
                    'matched_at': datetime.now().isoformat()
                }

                all_matches.append(match_result)
                self.stats['matches_found'] += total_matches
                self.stats['high_confidence_matches'] += high_conf

        if not all_matches:
            self.log(f"    [-] No vulnerabilities found")
            return None

        return {
            'plugin_slug': plugin_slug,
            'version': version,
            'scan_timestamp': datetime.now().isoformat(),
            'vulnerabilities_detected': len(all_matches),
            'total_matches': sum(m['total_matches'] for m in all_matches),
            'high_confidence_matches': sum(m['high_confidence_matches'] for m in all_matches),
            'matches': all_matches
        }

    def scan_all_plugins(
        self,
        ast_signatures_dir: Path,
        vulnerability_patterns: Dict[str, List[Dict]],
        output_dir: Path
    ) -> Dict:
        """
        Scan all plugins in AST signatures directory.

        Args:
            ast_signatures_dir: Directory containing plugin AST subdirectories
            vulnerability_patterns: Vulnerability patterns organized by plugin
            output_dir: Directory to save match results

        Returns:
            Summary statistics
        """
        # Create output directory
        output_dir.mkdir(parents=True, exist_ok=True)

        # Get all plugin directories
        plugin_dirs = [d for d in ast_signatures_dir.iterdir() if d.is_dir()]

        self.log(f"\n[*] Found {len(plugin_dirs)} plugin versions to scan")

        results_summary = {
            'scanned_plugins': [],
            'vulnerable_plugins': []
        }

        # Flatten all vulnerability patterns (check ALL patterns against ALL plugins)
        all_patterns = []
        for plugin_patterns in vulnerability_patterns.values():
            all_patterns.extend(plugin_patterns)

        self.log(f"[*] Will check {len(all_patterns)} total vulnerability patterns against all plugins")

        for plugin_dir in plugin_dirs:
            # Parse directory name: {plugin-slug}-{version}
            dir_name = plugin_dir.name
            parts = dir_name.rsplit('-', 1)

            if len(parts) != 2:
                self.log(f"[!] Skipping invalid directory name: {dir_name}")
                continue

            plugin_slug, version = parts

            self.stats['plugins_scanned'] += 1

            # Match against ALL vulnerability patterns (not just this plugin's patterns)
            match_result = self.match_plugin_against_patterns(
                plugin_slug,
                version,
                plugin_dir,
                all_patterns  # Check all patterns from all plugins!
            )

            if match_result:
                # Save results
                output_plugin_dir = output_dir / f"{plugin_slug}-{version}"
                output_plugin_dir.mkdir(parents=True, exist_ok=True)

                output_file = output_plugin_dir / 'vulnerability_matches.json'
                with open(output_file, 'w', encoding='utf-8') as f:
                    json.dump(match_result, f, indent=2, ensure_ascii=False)

                self.log(f"    [+] Saved results: {output_file}")

                results_summary['vulnerable_plugins'].append({
                    'plugin_slug': plugin_slug,
                    'version': version,
                    'vulnerabilities_count': match_result['vulnerabilities_detected'],
                    'total_matches': match_result['total_matches'],
                    'high_confidence_matches': match_result['high_confidence_matches']
                })

            results_summary['scanned_plugins'].append({
                'plugin_slug': plugin_slug,
                'version': version,
                'has_vulnerabilities': match_result is not None
            })

        return results_summary


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Match vulnerability patterns against plugin ASTs'
    )

    parser.add_argument(
        '--signatures',
        type=Path,
        default=Path('data/output/signatures'),
        help='Directory containing CVE signatures with AST patterns'
    )

    parser.add_argument(
        '--ast-signatures',
        type=Path,
        default=Path('data/output/ast_signatures'),
        help='Directory containing plugin AST signatures'
    )

    parser.add_argument(
        '--output-dir',
        type=Path,
        default=Path('data/output/vulnerability_matches'),
        help='Output directory for match results'
    )

    parser.add_argument(
        '--quiet',
        action='store_true',
        help='Reduce output verbosity'
    )

    args = parser.parse_args()

    print("=" * 80)
    print("  VULNERABILITY PATTERN MATCHER")
    print("=" * 80)

    # Check input directories
    if not args.signatures.exists():
        print(f"\n[!] Error: Signatures directory not found: {args.signatures}")
        print(f"[*] Please run generate_signatures.py first")
        return 1

    if not args.ast_signatures.exists():
        print(f"\n[!] Error: AST signatures directory not found: {args.ast_signatures}")
        print(f"[*] Please run generate_plugin_asts.py first")
        return 1

    # Initialize matcher
    matcher = VulnerabilityMatcher(verbose=not args.quiet)

    # Load vulnerability patterns from signatures
    print(f"\n[*] Loading vulnerability patterns from {args.signatures}")
    vulnerability_patterns = matcher.load_vulnerability_patterns(args.signatures)

    if not vulnerability_patterns:
        print(f"\n[!] No vulnerability patterns found")
        return 1

    # Scan all plugins
    try:
        print(f"\n[*] Scanning plugins in {args.ast_signatures}")
        results = matcher.scan_all_plugins(
            args.ast_signatures,
            vulnerability_patterns,
            args.output_dir
        )

        # Save summary
        summary_file = args.output_dir / 'scan_summary.json'
        summary_data = {
            'statistics': matcher.stats,
            'results': results,
            'scan_timestamp': datetime.now().isoformat()
        }

        with open(summary_file, 'w', encoding='utf-8') as f:
            json.dump(summary_data, f, indent=2)

        # Print summary
        print("\n" + "=" * 80)
        print("  SCAN COMPLETE")
        print("=" * 80)

        print(f"\n[*] Statistics:")
        print(f"    Vulnerability patterns loaded: {matcher.stats['vulnerability_patterns_loaded']}")
        print(f"    Plugins scanned: {matcher.stats['plugins_scanned']}")
        print(f"    Files scanned: {matcher.stats['files_scanned']}")
        print(f"    Total matches found: {matcher.stats['matches_found']}")
        print(f"    High-confidence matches: {matcher.stats['high_confidence_matches']}")

        print(f"\n[*] Vulnerable plugins found: {len(results['vulnerable_plugins'])}")

        if results['vulnerable_plugins']:
            print(f"\n[*] Vulnerable plugins:")
            for vuln_plugin in results['vulnerable_plugins']:
                print(f"    - {vuln_plugin['plugin_slug']} {vuln_plugin['version']}: "
                      f"{vuln_plugin['vulnerabilities_count']} vulnerabilities "
                      f"({vuln_plugin['high_confidence_matches']} high-confidence)")

        print(f"\n[+] Results saved to: {args.output_dir}/")
        print(f"[+] Summary saved to: {summary_file}")

        return 0

    except Exception as e:
        print(f"\n[!] Error: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
