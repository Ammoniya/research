#!/usr/bin/env python3
"""
Extract Vulnerability Patterns from CVE Signatures

This script processes CVE signature files and extracts minimal differing
subtrees (vulnerability patterns) for use in large-scale vulnerability scanning.

Usage:
    python extract_vulnerability_patterns.py [--input-dir signatures/] [--output-dir patterns/]
"""

import sys
import json
import argparse
from pathlib import Path
from typing import Dict, List, Optional
from collections import defaultdict

# Add package to path
sys.path.insert(0, str(Path(__file__).parent))

from wordpress_vulnerability_analyzer.ast_parser import PHPASTParser
from wordpress_vulnerability_analyzer.ast_differ import ASTDiffer
from wordpress_vulnerability_analyzer.models import CodeSignature, ASTSignature


class VulnerabilityPatternExtractor:
    """
    Extracts vulnerability patterns from signature files.
    """

    def __init__(self, verbose: bool = True):
        """Initialize the extractor."""
        self.verbose = verbose
        self.parser = PHPASTParser()
        self.differ = ASTDiffer(ignore_whitespace=True, ignore_comments=True)
        self.stats = {
            'total_signatures': 0,
            'processed': 0,
            'successful': 0,
            'failed': 0,
            'no_code': 0,
            'parse_errors': 0,
            'patterns_extracted': 0
        }

    def log(self, message: str):
        """Print log message if verbose."""
        if self.verbose:
            print(message)

    def extract_pattern_from_signature(
        self,
        signature_file: Path
    ) -> Optional[Dict]:
        """
        Extract vulnerability pattern from a signature file.

        Args:
            signature_file: Path to signature JSON file

        Returns:
            Dictionary containing extracted pattern, or None if extraction fails
        """
        self.log(f"\n[*] Processing: {signature_file.name}")

        try:
            # Load signature
            with open(signature_file, 'r', encoding='utf-8') as f:
                sig_data = json.load(f)

            # Check if we have pre/post patch code
            pre_patch_code = sig_data.get('pre_patch_code', '')
            post_patch_code = sig_data.get('post_patch_code', '')

            if not pre_patch_code or not post_patch_code:
                self.log("    [!] No pre/post patch code found")
                self.stats['no_code'] += 1
                return None

            # Parse vulnerable code
            self.log("    [*] Parsing vulnerable code...")
            vuln_ast = self.parser.parse(pre_patch_code)

            if not vuln_ast:
                self.log("    [!] Failed to parse vulnerable code")
                self.stats['parse_errors'] += 1
                return None

            # Parse patched code
            self.log("    [*] Parsing patched code...")
            patch_ast = self.parser.parse(post_patch_code)

            if not patch_ast:
                self.log("    [!] Failed to parse patched code")
                self.stats['parse_errors'] += 1
                return None

            # Diff the ASTs
            self.log("    [*] Computing AST differences...")
            all_diffs = self.differ.diff(vuln_ast, patch_ast)

            if not all_diffs:
                self.log("    [!] No differences found")
                return None

            # Get minimal diffs
            minimal_diffs = self.differ.get_minimal_diffs(all_diffs)
            self.log(f"    [+] Found {len(all_diffs)} diffs, {len(minimal_diffs)} minimal")

            # Get security-relevant diffs
            security_diffs = self.differ.get_security_relevant_diffs(minimal_diffs)
            self.log(f"    [+] {len(security_diffs)} security-relevant diffs")

            # Use security diffs if available, otherwise minimal diffs
            pattern_diffs = security_diffs if security_diffs else minimal_diffs

            # Extract pattern information
            pattern = {
                'metadata': {
                    'cve': sig_data.get('cve'),
                    'plugin_slug': sig_data.get('plugin_slug'),
                    'vuln_type': sig_data.get('vuln_type'),
                    'title': sig_data.get('title'),
                    'vulnerable_version': sig_data.get('vulnerable_version'),
                    'patched_version': sig_data.get('patched_version'),
                    'wordfence_uuid': sig_data.get('wordfence_uuid'),
                },

                'vulnerable_pattern': {
                    'code': pre_patch_code,
                    'ast': self.parser.simplify_ast(vuln_ast, max_depth=8).to_dict(),
                    'signature': vuln_ast.get_node_signature()
                },

                'patched_pattern': {
                    'code': post_patch_code,
                    'ast': self.parser.simplify_ast(patch_ast, max_depth=8).to_dict(),
                    'signature': patch_ast.get_node_signature()
                },

                'diffs': [
                    {
                        'type': diff.diff_type,
                        'description': diff.description,
                        'path': diff.path,
                        'vulnerable_node': diff.vulnerable_node.to_dict() if diff.vulnerable_node else None,
                        'patched_node': diff.patched_node.to_dict() if diff.patched_node else None,
                    }
                    for diff in pattern_diffs
                ],

                'diff_summary': self.differ.diff_summary(all_diffs),

                'security_functions': self._extract_security_functions(pattern_diffs),

                'pattern_hash': self._compute_pattern_hash(vuln_ast, patch_ast)
            }

            self.stats['patterns_extracted'] += 1
            self.log(f"    [âœ“] Pattern extracted successfully")

            return pattern

        except Exception as e:
            self.log(f"    [!] Error: {e}")
            self.stats['failed'] += 1
            return None

    def _extract_security_functions(self, diffs: List) -> Dict[str, List[str]]:
        """
        Extract security-related function names from diffs.

        Args:
            diffs: List of AST diffs

        Returns:
            Dictionary with 'added' and 'removed' function lists
        """
        security_keywords = {
            'wp_nonce', 'check_admin_referer', 'check_ajax_referer',
            'current_user_can', 'is_admin', 'is_user_logged_in',
            'sanitize_', 'esc_', 'wp_kses', 'prepare', 'wpdb',
            'wp_verify_nonce', 'htmlspecialchars', 'htmlentities',
            'strip_tags', 'filter_', 'password_', 'hash_'
        }

        added = set()
        removed = set()

        for diff in diffs:
            if diff.diff_type == 'added' and diff.patched_node:
                text = diff.patched_node.text.lower()
                for keyword in security_keywords:
                    if keyword.lower() in text:
                        added.add(keyword)

            elif diff.diff_type == 'removed' and diff.vulnerable_node:
                text = diff.vulnerable_node.text.lower()
                for keyword in security_keywords:
                    if keyword.lower() in text:
                        removed.add(keyword)

        return {
            'added': sorted(list(added)),
            'removed': sorted(list(removed))
        }

    def _compute_pattern_hash(self, vuln_ast, patch_ast) -> str:
        """
        Compute a hash for the pattern to detect duplicates.

        Args:
            vuln_ast: Vulnerable AST
            patch_ast: Patched AST

        Returns:
            Hash string
        """
        import hashlib

        # Use structure signatures, not full code
        vuln_sig = vuln_ast.get_node_signature()
        patch_sig = patch_ast.get_node_signature()

        combined = f"{vuln_sig}|{patch_sig}"
        return hashlib.sha256(combined.encode()).hexdigest()[:16]

    def process_signature_directory(
        self,
        input_dir: Path,
        output_dir: Path,
        limit: Optional[int] = None
    ) -> Dict:
        """
        Process all signature files in a directory.

        Args:
            input_dir: Directory containing signature JSON files
            output_dir: Directory to save extracted patterns
            limit: Optional limit on number of signatures to process

        Returns:
            Statistics dictionary
        """
        # Find all signature files
        signature_files = list(input_dir.rglob('*.json'))
        self.stats['total_signatures'] = len(signature_files)

        if limit:
            signature_files = signature_files[:limit]

        self.log(f"\n[*] Found {len(signature_files)} signature files")
        if limit:
            self.log(f"[*] Processing first {limit} files")

        # Create output directory
        output_dir.mkdir(parents=True, exist_ok=True)

        # Process each signature
        patterns_by_type = defaultdict(list)
        pattern_hashes = set()

        for i, sig_file in enumerate(signature_files, 1):
            self.log(f"\n[{i}/{len(signature_files)}] {sig_file.relative_to(input_dir)}")

            self.stats['processed'] += 1

            pattern = self.extract_pattern_from_signature(sig_file)

            if pattern:
                # Check for duplicates
                pattern_hash = pattern['pattern_hash']

                if pattern_hash in pattern_hashes:
                    self.log("    [!] Duplicate pattern (skipping)")
                    continue

                pattern_hashes.add(pattern_hash)

                # Group by vulnerability type
                vuln_type = pattern['metadata']['vuln_type']
                patterns_by_type[vuln_type].append(pattern)

                # Save individual pattern
                plugin_slug = pattern['metadata']['plugin_slug']
                cve = pattern['metadata']['cve'] or pattern['metadata']['wordfence_uuid'] or 'unknown'

                plugin_dir = output_dir / plugin_slug
                plugin_dir.mkdir(exist_ok=True)

                pattern_file = plugin_dir / f"{cve}_pattern.json"

                with open(pattern_file, 'w', encoding='utf-8') as f:
                    json.dump(pattern, f, indent=2, ensure_ascii=False)

                self.log(f"    [+] Saved: {pattern_file.relative_to(output_dir)}")
                self.stats['successful'] += 1

        # Save patterns grouped by type
        self.log(f"\n[*] Saving patterns grouped by vulnerability type...")

        for vuln_type, patterns in patterns_by_type.items():
            # Clean filename
            safe_type = vuln_type.replace('/', '_').replace(' ', '_').lower()
            type_file = output_dir / f"patterns_{safe_type}.json"

            with open(type_file, 'w', encoding='utf-8') as f:
                json.dump({
                    'vulnerability_type': vuln_type,
                    'pattern_count': len(patterns),
                    'patterns': patterns
                }, f, indent=2, ensure_ascii=False)

            self.log(f"    [+] Saved {len(patterns)} patterns: {type_file.name}")

        # Save summary
        summary = {
            'statistics': self.stats,
            'patterns_by_type': {
                vuln_type: len(patterns)
                for vuln_type, patterns in patterns_by_type.items()
            },
            'unique_patterns': len(pattern_hashes)
        }

        summary_file = output_dir / 'extraction_summary.json'
        with open(summary_file, 'w', encoding='utf-8') as f:
            json.dump(summary, f, indent=2)

        self.log(f"\n[+] Summary saved: {summary_file}")

        return summary


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Extract vulnerability patterns from CVE signatures'
    )

    parser.add_argument(
        '--input-dir',
        type=Path,
        default=Path('signatures'),
        help='Input directory containing signature files (default: signatures/)'
    )

    parser.add_argument(
        '--output-dir',
        type=Path,
        default=Path('vulnerability_patterns'),
        help='Output directory for extracted patterns (default: vulnerability_patterns/)'
    )

    parser.add_argument(
        '--limit',
        type=int,
        default=None,
        help='Limit number of signatures to process (for testing)'
    )

    parser.add_argument(
        '--quiet',
        action='store_true',
        help='Reduce output verbosity'
    )

    args = parser.parse_args()

    print("=" * 80)
    print("  VULNERABILITY PATTERN EXTRACTOR")
    print("=" * 80)

    # Check input directory
    if not args.input_dir.exists():
        print(f"\n[!] Error: Input directory not found: {args.input_dir}")
        print(f"[*] Please run generate_signatures.py first to create signature files.")
        return 1

    # Initialize extractor
    extractor = VulnerabilityPatternExtractor(verbose=not args.quiet)

    # Process signatures
    try:
        summary = extractor.process_signature_directory(
            args.input_dir,
            args.output_dir,
            limit=args.limit
        )

        # Print summary
        print("\n" + "=" * 80)
        print("  EXTRACTION COMPLETE")
        print("=" * 80)

        print(f"\n[*] Statistics:")
        print(f"    Total signatures: {summary['statistics']['total_signatures']}")
        print(f"    Processed: {summary['statistics']['processed']}")
        print(f"    Successful: {summary['statistics']['successful']}")
        print(f"    Failed: {summary['statistics']['failed']}")
        print(f"    No code: {summary['statistics']['no_code']}")
        print(f"    Parse errors: {summary['statistics']['parse_errors']}")
        print(f"    Patterns extracted: {summary['statistics']['patterns_extracted']}")
        print(f"    Unique patterns: {summary['unique_patterns']}")

        if summary['statistics']['processed'] > 0:
            success_rate = (summary['statistics']['successful'] / summary['statistics']['processed']) * 100
            print(f"    Success rate: {success_rate:.1f}%")

        print(f"\n[*] Patterns by vulnerability type:")
        for vuln_type, count in sorted(summary['patterns_by_type'].items(), key=lambda x: x[1], reverse=True):
            print(f"    {vuln_type}: {count}")

        print(f"\n[+] Patterns saved to: {args.output_dir}/")
        print(f"[*] Use these patterns to scan for vulnerability clones!")

        return 0

    except Exception as e:
        print(f"\n[!] Error: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
