"""Scores crash exploitability using CVSS-like methodology."""

from .models import CrashReport, CrashType, SeverityLevel


class ExploitabilityScorer:
    """Calculates exploitability scores for crashes."""

    def calculate_exploitability_score(self, crash: CrashReport) -> float:
        """
        Calculate exploitability score (0-10).

        Based on CVSS v3.1 methodology:
        - Attack Vector (AV): 0-4 points
        - Attack Complexity (AC): 0-2 points
        - Privileges Required (PR): 0-2 points
        - Impact: 0-2 points

        Args:
            crash: CrashReport to score

        Returns:
            float: Exploitability score (0-10)
        """
        score = 0.0

        # Attack Vector (0-4 points)
        av_scores = {
            'network': 4.0,
            'adjacent': 2.0,
            'local': 1.0,
            'physical': 0.5,
        }
        score += av_scores.get(crash.attack_vector, 2.0)

        # Attack Complexity (0-2 points)
        ac_scores = {
            'low': 2.0,
            'medium': 1.0,
            'high': 0.5,
        }
        score += ac_scores.get(crash.attack_complexity, 1.0)

        # Privileges Required (0-2 points)
        pr_scores = {
            'none': 2.0,
            'low': 1.0,
            'high': 0.5,
        }
        score += pr_scores.get(crash.privileges_required, 1.0)

        # Impact (0-2 points)
        impact_scores = {
            'critical': 2.0,
            'high': 1.5,
            'medium': 1.0,
            'low': 0.5,
        }
        score += impact_scores.get(crash.impact_level, 1.0)

        return min(score, 10.0)

    def calculate_cvss_score(
        self,
        crash_type: CrashType,
        attack_vector: str = "network",
        attack_complexity: str = "low",
        privileges_required: str = "none",
        user_interaction: str = "none",
        confidentiality_impact: str = "high",
        integrity_impact: str = "high",
        availability_impact: str = "low",
    ) -> tuple:
        """
        Calculate CVSS v3.1 score and vector.

        Returns:
            tuple: (score, vector_string)
        """
        # Base score calculation (simplified CVSS)
        av_scores = {'network': 0.85, 'adjacent': 0.62, 'local': 0.55}
        ac_scores = {'low': 0.77, 'high': 0.44}
        pr_scores = {'none': 0.85, 'low': 0.62, 'high': 0.27}
        ui_scores = {'none': 0.85, 'required': 0.62}

        impact_scores = {'none': 0.0, 'low': 0.22, 'high': 0.56}

        exploitability = (
            av_scores.get(attack_vector, 0.85) *
            ac_scores.get(attack_complexity, 0.77) *
            pr_scores.get(privileges_required, 0.85) *
            ui_scores.get(user_interaction, 0.85)
        )

        impact = 1 - (
            (1 - impact_scores.get(confidentiality_impact, 0.56)) *
            (1 - impact_scores.get(integrity_impact, 0.56)) *
            (1 - impact_scores.get(availability_impact, 0.22))
        )

        if impact <= 0:
            base_score = 0.0
        else:
            base_score = min(10.0, (exploitability + impact) * 5.0)

        # Generate CVSS vector string
        vector = (
            f"CVSS:3.1/"
            f"AV:{attack_vector[0].upper()}/"
            f"AC:{attack_complexity[0].upper()}/"
            f"PR:{privileges_required[0].upper()}/"
            f"UI:{user_interaction[0].upper()}/"
            f"S:U/"
            f"C:{confidentiality_impact[0].upper()}/"
            f"I:{integrity_impact[0].upper()}/"
            f"A:{availability_impact[0].upper()}"
        )

        return round(base_score, 1), vector

    def determine_severity(self, cvss_score: float) -> SeverityLevel:
        """
        Determine severity level from CVSS score.

        Args:
            cvss_score: CVSS score (0-10)

        Returns:
            SeverityLevel: Severity classification
        """
        if cvss_score >= 9.0:
            return SeverityLevel.CRITICAL
        elif cvss_score >= 7.0:
            return SeverityLevel.HIGH
        elif cvss_score >= 4.0:
            return SeverityLevel.MEDIUM
        else:
            return SeverityLevel.LOW

    def assess_crash_characteristics(self, crash: CrashReport) -> dict:
        """
        Assess crash characteristics for exploitability.

        Args:
            crash: CrashReport to assess

        Returns:
            dict: Characteristics assessment
        """
        characteristics = {
            'attack_vector': 'network',
            'attack_complexity': 'low',
            'privileges_required': 'none',
            'user_interaction': 'none',
            'confidentiality_impact': 'high',
            'integrity_impact': 'high',
            'availability_impact': 'low',
        }

        # Adjust based on crash type
        if crash.crash_type == CrashType.SQL_ERROR:
            characteristics.update({
                'confidentiality_impact': 'high',
                'integrity_impact': 'high',
                'availability_impact': 'low',
            })
        elif crash.crash_type == CrashType.XSS_DETECTED:
            characteristics.update({
                'confidentiality_impact': 'low',
                'integrity_impact': 'high',
                'availability_impact': 'none',
            })
        elif crash.crash_type == CrashType.CSRF_DETECTED:
            characteristics.update({
                'user_interaction': 'required',
                'confidentiality_impact': 'low',
                'integrity_impact': 'high',
                'availability_impact': 'low',
            })
        elif crash.crash_type == CrashType.PATH_TRAVERSAL:
            characteristics.update({
                'confidentiality_impact': 'high',
                'integrity_impact': 'low',
                'availability_impact': 'none',
            })
        elif crash.crash_type == CrashType.AUTH_BYPASS:
            characteristics.update({
                'confidentiality_impact': 'high',
                'integrity_impact': 'high',
                'availability_impact': 'high',
            })

        return characteristics

    def score_crash(self, crash: CrashReport) -> CrashReport:
        """
        Score a crash and update its fields.

        Args:
            crash: CrashReport to score

        Returns:
            CrashReport: Updated crash report with scores
        """
        # Calculate exploitability score
        crash.exploitability_score = self.calculate_exploitability_score(crash)

        # Assess characteristics
        characteristics = self.assess_crash_characteristics(crash)

        # Update crash with characteristics
        crash.attack_vector = characteristics['attack_vector']
        crash.attack_complexity = characteristics['attack_complexity']
        crash.privileges_required = characteristics['privileges_required']
        crash.user_interaction = characteristics['user_interaction']
        crash.impact_level = characteristics.get('impact_level', 'high')

        # Calculate CVSS score
        cvss_score, cvss_vector = self.calculate_cvss_score(
            crash_type=crash.crash_type,
            **characteristics
        )

        crash.cvss_score = cvss_score
        crash.cvss_vector = cvss_vector

        # Determine severity
        crash.severity = self.determine_severity(cvss_score)

        # Determine if exploitable
        crash.is_exploitable = crash.exploitability_score >= 5.0

        return crash
